<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[经验分享08]-通过Cloudreve在VPS上搭建私人云盘</title>
      <link href="/2020/05/03/jing-yan-fen-xiang-08-tong-guo-cloudreve-zai-vps-shang-da-jian-si-ren-yun-pan/"/>
      <url>/2020/05/03/jing-yan-fen-xiang-08-tong-guo-cloudreve-zai-vps-shang-da-jian-si-ren-yun-pan/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="经验分享08-通过Cloudreve在VPS上搭建私人云盘"><a href="#经验分享08-通过Cloudreve在VPS上搭建私人云盘" class="headerlink" title="[经验分享08]-通过Cloudreve在VPS上搭建私人云盘"></a>[经验分享08]-通过Cloudreve在VPS上搭建私人云盘</h1><h2 id="1-私人云盘最终效果展示"><a href="#1-私人云盘最终效果展示" class="headerlink" title="1.私人云盘最终效果展示"></a>1.私人云盘最终效果展示</h2><p><img src="pic/2020/05/%E4%BA%91%E7%9B%98%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2.png" alt="云盘登录界面"></p><p><img src="pic/2020/05/%E4%B8%AA%E4%BA%BA%E4%BA%91%E7%9B%98%E4%B8%BB%E7%95%8C%E9%9D%A2.png" alt="个人云盘主界面"></p><p><img src="pic/2020/05/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E9%80%9F%E5%BA%A6.png" alt="文件上传速度"></p><p><img src="pic/2020/05/%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E9%80%9F%E5%BA%A6.png" alt="文件下载速度"></p><h2 id="2-搭建前准备工作"><a href="#2-搭建前准备工作" class="headerlink" title="2.搭建前准备工作"></a>2.搭建前准备工作</h2><h3 id="2-1-VPS云服务器购买"><a href="#2-1-VPS云服务器购买" class="headerlink" title="2.1 VPS云服务器购买"></a>2.1 VPS云服务器购买</h3><p>如果有信用卡可以白嫖<code>谷歌云</code>的服务器，而这里我们购买的是阿里云<code>香港服务器,系统镜像为</code>Debian9<code>,价格为</code>24/月`,配置很简单，设置好密码后即可在网页端登陆刚刚购买的服务器了。</p><blockquote><p>搜了搜网上推荐的<a href="https://www.pianyivps.com/3229.html" target="_blank" rel="noopener">vps购买指南</a>贴在下面👇</p><p><img src="https://pic.downk.cc/item/5ea6c973c2a9a83be5aa881f.png" alt="各VPS对比"></p></blockquote><h3 id="2-2-宝塔linux面板安装"><a href="#2-2-宝塔linux面板安装" class="headerlink" title="2.2 宝塔linux面板安装"></a>2.2 宝塔linux面板安装</h3><p>参考：<a href="https://www.dhzy.fun/archives/1811.html" target="_blank" rel="noopener">大海资源网-超简单个人网盘搭建教程</a></p><h4 id="1、官方支持的网站和文档"><a href="#1、官方支持的网站和文档" class="headerlink" title="1、官方支持的网站和文档"></a>1、官方支持的网站和文档</h4><ul><li>官网：<a href="https://cloudreve.org/" target="_blank" rel="noopener">https://cloudreve.org/</a></li><li>github：<a href="https://github.com/cloudreve/Cloudreve" target="_blank" rel="noopener">https://github.com/cloudreve/Cloudreve</a></li><li>下载：<a href="https://github.com/cloudreve/Cloudreve/releases" target="_blank" rel="noopener">https://github.com/cloudreve/Cloudreve/releases</a></li><li>安装文档：<a href="https://docs.cloudreve.org/getting-started/install" target="_blank" rel="noopener">https://docs.cloudreve.org/getting-started/install</a></li><li>演示：<a href="https://demo.cloudreve.org" target="_blank" rel="noopener">https://demo.cloudreve.org</a></li></ul><h4 id="2、宝塔命令行输入代码查询内核参数"><a href="#2、宝塔命令行输入代码查询内核参数" class="headerlink" title="2、宝塔命令行输入代码查询内核参数"></a>2、宝塔命令行输入代码查询内核参数</h4><pre><code>arch</code></pre><p>输出结果x86_64代表amd64；aarch64代表arm64</p><p><img src="pic/2020/05/%E5%AE%9D%E5%A1%94linux%E5%AE%89%E8%A3%85%E7%95%8C%E9%9D%A2.png" alt="宝塔linux安装界面"></p><h4 id="3、下载链接处找到对应的版本-复制链接地址"><a href="#3、下载链接处找到对应的版本-复制链接地址" class="headerlink" title="3、下载链接处找到对应的版本,复制链接地址"></a>3、下载链接处找到对应的版本,复制链接地址</h4><p><img src="pic/2020/05/%E5%AE%9D%E5%A1%94linux%E4%B8%8B%E8%BD%BD%E7%95%8C%E9%9D%A2.png" alt="宝塔linux下载界面"></p><h4 id="4、宝塔安全添加5212端口"><a href="#4、宝塔安全添加5212端口" class="headerlink" title="4、宝塔安全添加5212端口"></a>4、宝塔安全添加5212端口</h4><p><img src="pic/2020/05/%E5%AE%9D%E5%A1%94linux%E7%AB%AF%E5%8F%A3%E7%95%8C%E9%9D%A2.png" alt="宝塔linux端口设置界面"></p><h4 id="5、宝塔命令行逐行执行以下命令，对应链接处改为自己复制的："><a href="#5、宝塔命令行逐行执行以下命令，对应链接处改为自己复制的：" class="headerlink" title="5、宝塔命令行逐行执行以下命令，对应链接处改为自己复制的："></a>5、宝塔命令行逐行执行以下命令，对应链接处改为自己复制的：</h4><h4 id="（当然你也可以把下边的改成自己的然后全部复制黏贴就完事了）"><a href="#（当然你也可以把下边的改成自己的然后全部复制黏贴就完事了）" class="headerlink" title="（当然你也可以把下边的改成自己的然后全部复制黏贴就完事了）"></a>（当然你也可以把下边的改成自己的然后全部复制黏贴就完事了）</h4><pre class=" language-linux"><code class="language-linux">mkdir /www/wwwroot/cloudreve # 新建一个文件夹存放程序cd /www/wwwroot/cloudreve # 进入该文件夹wget https://github.com/cloudreve/Cloudreve/releases/download/3.0.0/cloudreve_3.0.0_linux_amd64.tar.gz # 下载你复制的链接tar -zxvf cloudreve_3.0.0_linux_amd64.tar.gz # 解压获取到的主程序chmod +x ./cloudreve # 赋予执行权限./cloudreve # 启动 Cloudreve</code></pre><h4 id="6、安装完成，保存账户和登录密码，务必保存该密码，测试登录"><a href="#6、安装完成，保存账户和登录密码，务必保存该密码，测试登录" class="headerlink" title="6、安装完成，保存账户和登录密码，务必保存该密码，测试登录"></a>6、安装完成，保存账户和登录密码，务必保存该密码，测试登录</h4><p>登录地址为服务器ip:5212，比如<a href="http://192.168.0.125:5212/" target="_blank" rel="noopener">http://192.168.0.125:5212/</a></p><p><img src="pic/2020/05/%E4%BA%91%E7%9B%98%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2.png" alt="云盘登录界面"></p><h4 id="7、想要无忧使用，最好是加个进程守护，这样就不需要每次都到后台启动进程"><a href="#7、想要无忧使用，最好是加个进程守护，这样就不需要每次都到后台启动进程" class="headerlink" title="7、想要无忧使用，最好是加个进程守护，这样就不需要每次都到后台启动进程"></a>7、想要无忧使用，最好是加个进程守护，这样就不需要每次都到后台启动进程</h4><p> 命令行端口ctrl+c，停止进程后关闭即可 </p><p> 感谢宝塔能够安装Supervisor管理器 </p><p><img src="pic/2020/05/%E5%AE%9D%E5%A1%94linux%E8%BF%9B%E7%A8%8B%E9%85%8D%E7%BD%AE.png" alt="宝塔linux进程配置"></p><p>配置这样填：</p><p><img src="pic/2020/05/%E5%AE%9D%E5%A1%94linux%E8%BF%9B%E7%A8%8B%E9%85%8D%E7%BD%AE%E7%95%8C%E9%9D%A2.png" alt="宝塔linux进程配置界面"></p><p><strong>添加成功后，看下进程状态是否为开启的绿三角，假如不是就重启服务器，再回来看下，还不是就检查配置是否正确。</strong></p><p><strong>搞到这里基本就能正常使用网盘了</strong></p>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[经验分享07]-配置V2ray服务器</title>
      <link href="/2020/04/27/jing-yan-fen-xiang-07-pei-zhi-v2ray-fu-wu-qi/"/>
      <url>/2020/04/27/jing-yan-fen-xiang-07-pei-zhi-v2ray-fu-wu-qi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="随手搭建VPS服务器"><a href="#随手搭建VPS服务器" class="headerlink" title="随手搭建VPS服务器"></a>随手搭建VPS服务器</h1><p>刚上大学那会儿沉迷这个好久，那时候更多的是好奇，没有对技术的追求。</p><p>现在研究生出于学习的需要得随手配置好这玩意儿，毕竟baidu能搜到的东西确实有限。</p><p>无他，五一还没开学已经没有尽头搞科研了，emmmmm</p><h2 id="1-服务器购买指南"><a href="#1-服务器购买指南" class="headerlink" title="1.服务器购买指南"></a>1.服务器购买指南</h2><p>如果有信用卡可以白嫖<code>谷歌云</code>的服务器，而这里我们购买的是阿里云<code>香港</code>服务器,<br>系统镜像为<code>Debian9</code>,价格为<code>24/月</code>,配置很简单，设置好密码后即可在网页端登陆<br>刚刚购买的服务器了。</p><blockquote><p>搜了搜网上推荐的<a href="https://www.pianyivps.com/3229.html" target="_blank" rel="noopener">vps购买指南</a>贴在下面👇</p><p><img src="https://pic.downk.cc/item/5ea6c973c2a9a83be5aa881f.png" alt="各VPS对比"></p></blockquote><h2 id="2-服务器配置v2ray"><a href="#2-服务器配置v2ray" class="headerlink" title="2.服务器配置v2ray"></a>2.服务器配置v2ray</h2><p>这里我们选择配置<code>v2ray</code>服务，考虑到前一阵时间流行的<code>ssr</code>现在没有那么好用了，加上朋友前<br>不久给了我个v2ray的码试用了一下发现还<code>真不错</code>，就查了查资料动手搭建一个自己的服务器。<br><br>具体是这样描述的：</p><pre><code>V2Ray 是一个于 Shadowsocks 之后非常好用的代理软件，但是由于 V2Ray 的配置略复杂，加之GUI 客户端不是很完善(现在完善了)，所以 V2Ray 并没有像 Shadowsocks 在科学上网人群之中那么流行。</code></pre><p>如果服务器已经买了，钱也氪了，马上就可以成功了～</p><blockquote><p>参考<a href="https://www.pianyivps.com/3229.html" target="_blank" rel="noopener">youtube教程</a></p></blockquote><ul><li>如果视频如果看不了，简单地可归纳为如下指令（详情请查看<a href="https://github.com/233boy/v2ray" target="_blank" rel="noopener">github教程</a>）:<pre><code>ubuntu/debian 系统安装 Curl 方法: $ apt-get update -y &amp;&amp; apt-get install curl -y$ bash &lt;(curl -s -L https://git.io/v2ray.sh)</code></pre></li></ul><p>然后我们选择<code>安装</code>,<code>TCP</code>,<code>Enter</code>,<code>N</code>,<code>N</code>,<code>Enter</code><br><br>简单点一路回车就行了，一键配置简不简单?</p><h2 id="3-导出配置信息并连接"><a href="#3-导出配置信息并连接" class="headerlink" title="3.导出配置信息并连接"></a>3.导出配置信息并连接</h2><blockquote><p>配置完成后服务器信息</p></blockquote><pre><code>---------- V2Ray 配置信息 -------------地址 (Address) = 134.123.255.255端口 (Port) = 66666用户ID (User ID / UUID) = c088f95d-4f98-94c6dga0额外ID (Alter Id) = 000传输协议 (Network) = tcp伪装类型 (header type) = none</code></pre><p>看到这个其实我们的配置就已经完成了，通过在win/mac/ubuntu/ios/安卓等的客户端<br>导入上面的配置信息就可以食用了，但是这样有点麻烦，相比之下<br>我更倾向于导出<code>二维码</code>或者下面这种<code>vmess</code>长连接的形式：</p><ul><li><code>vmess://ewoidiI6ICIyIiwKInBzIjog??????????E0OS4TEwLjE50IjogIjQwMTYxIiwK</code></li></ul><p>启动我们的服务查看一下有哪些配置选项～</p><pre><code>$ v2ray</code></pre><p>第三项中能够生成多种可导入的配置信息，进行菜单项的选择即可。</p><h2 id="4-配置防火墙规则"><a href="#4-配置防火墙规则" class="headerlink" title="4.配置防火墙规则"></a>4.配置防火墙规则</h2><p>前面的配置很快，在实际操作中也是忽略了这一点，导致本地配置完成后连接一直没有生效，查阅资料<br>发现谷歌云与阿里云都要多一个设置防火墙端口功能的配置。</p><p><img src="https://pic.downk.cc/item/5ea6cb50c2a9a83be5ac1b01.png" alt="防火墙设置"></p><p>查找一下防火墙配置：协议是 tcp，端口是 40234(<strong>该处写自己的端口号和协议</strong>)，<br>流量方向是入站，最后点击确定按钮，简单设置即可生效。</p><p><img src="https://pic.downk.cc/item/5ea6c974c2a9a83be5aa8922.png" alt=""></p><h2 id="5-客户端配置"><a href="#5-客户端配置" class="headerlink" title="5.客户端配置"></a>5.客户端配置</h2><h3 id="win"><a href="#win" class="headerlink" title="win"></a>win</h3><p><a href="https://github.com/2dust/v2rayN/releases/download/3.12/v2rayN-Core.zip" target="_blank" rel="noopener">V2Ray内核 + V2RayN打包下载</a></p><pre><code>1.将下载的V2Ray内核压缩包解压至任意位置。2.将下载的图形化界面文件V2RayN.exe移动到V2Ray解压后的目录内。3.运行V2RayN.exe即可。</code></pre><h3 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h3><p>使用swift编写,支持vmess,shadowsocks,socks5等服务协议,支持订阅, 支持二维码,剪贴板导入,手动配置,二维码分享</p><p><a href="https://github.com/yanue/V2rayU" target="_blank" rel="noopener">链接</a></p><h3 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h3><p>没有比较好的推荐…有试过一个萝卜图标的，没配置好就不玩了hhh</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>SSR 和 V2Ray 二者只用一个即可，网上有很多测速，都说明 V2Ray 比 SSR 更快，并且更不容易被墙识别，所以我建议就用 V2Ray 好了，BBR 加速也是需要配置，不配置 BBR 和 配置 BBR 网速也有一定差距的。</p><p>你肯定想问既然 V2Ray 这么好，为什么还有人用 SSR？</p><p>其实 V2Ray 也有缺点，那就是配置稍微有点复杂，对于新手来说可能很不友好，以上。</p><h2 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h2><p>两个还不错的资源站，有能力的玩家可以捡漏.<br><br><a href="https://www.youneed.win/free-v2ray" target="_blank" rel="noopener">https://www.youneed.win/free-v2ray</a><br><br><br><a href="https://t.me/s/V2List" target="_blank" rel="noopener">https://t.me/s/V2List</a></p>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>添加图片和视频</title>
      <link href="/2020/04/20/tian-jia-tu-pian/"/>
      <url>/2020/04/20/tian-jia-tu-pian/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=94434635&bvid=BV1XE411u79n&cid=161217076&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><p><img src="/pic/2020/04/fly_together.gif" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> 功能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[经验分享06]-推荐一个超好用的手机浏览器</title>
      <link href="/2020/04/09/jing-yan-fen-xiang-06-tui-jian-yi-ge-chao-hao-yong-de-shou-ji-liu-lan-qi/"/>
      <url>/2020/04/09/jing-yan-fen-xiang-06-tui-jian-yi-ge-chao-hao-yong-de-shou-ji-liu-lan-qi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="经验分享06-推荐一个超好用的手机浏览器"><a href="#经验分享06-推荐一个超好用的手机浏览器" class="headerlink" title="[经验分享06]-推荐一个超好用的手机浏览器"></a>[经验分享06]-推荐一个超好用的手机浏览器</h1><p>最近，找到一个比较好用的浏览器 kiwi浏览器（安卓版）。它能够像谷歌浏览器PC版一样，可以支持各种谷歌浏览器插件。并且还支持个性化定制。通过kiwi浏览器，再安装相应的插件（如谷歌上网助手[收费，但网速稳定]，麦殼兒Maikr[免费], Greenhub Socks Proxy[免费]等插件），就可以实现很多非常强大的功能。</p><p>我使用的插件是谷歌上网助手，通过kiwi手机浏览器，可以完成很多强大的功能，具体效果如下图所示：</p><p><img src="https://pic.downk.cc/item/5e8f2f72504f4bcb048a8271.png" alt=""></p><p><img src="https://pic.downk.cc/item/5e8f2f72504f4bcb048a8274.png" alt=""></p><p><img src="https://pic.downk.cc/item/5e8f2f72504f4bcb048a8278.png" alt=""></p><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h4 id="文件下载地址："><a href="#文件下载地址：" class="headerlink" title="文件下载地址："></a>文件下载地址：</h4><p>链接：<a href="https://www.lanzous.com/ib7377a" target="_blank" rel="noopener">https://www.lanzous.com/ib7377a</a></p>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Matalb使用-课程学习]-图像分割与目标计数</title>
      <link href="/2020/04/03/matalb-shi-yong-ke-cheng-xue-xi-tu-xiang-fen-ge-yu-mu-biao-ji-shu/"/>
      <url>/2020/04/03/matalb-shi-yong-ke-cheng-xue-xi-tu-xiang-fen-ge-yu-mu-biao-ji-shu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-基于分水岭算法的图像分割及目标计数"><a href="#1-基于分水岭算法的图像分割及目标计数" class="headerlink" title="1 基于分水岭算法的图像分割及目标计数"></a>1 基于分水岭算法的图像分割及目标计数</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>在<a href="https://zh.wikipedia.org/wiki/计算机视觉" target="_blank" rel="noopener">计算机视觉</a>领域，图像分割（Segmentation）指的是将<a href="https://zh.wikipedia.org/wiki/数字图像" target="_blank" rel="noopener">数字图像</a>细分为多个图像子区域（像素的<a href="https://zh.wikipedia.org/wiki/集合" target="_blank" rel="noopener">集合</a>）（也被称作超像素）的过程。图像分割的目的是简化或改变图像的表示形式，使得图像更容易理解和分析。图像分割通常用于定位图像中的物体和<a href="https://zh.wikipedia.org/wiki/边界" target="_blank" rel="noopener">边界</a>（<a href="https://zh.wikipedia.org/wiki/线" target="_blank" rel="noopener">线</a>，<a href="https://zh.wikipedia.org/wiki/曲线" target="_blank" rel="noopener">曲线</a>等）。更精确的，图像分割是对图像中的每个<a href="https://zh.wikipedia.org/wiki/像素" target="_blank" rel="noopener">像素</a>加<a href="https://zh.wikipedia.org/wiki/标签" target="_blank" rel="noopener">标签</a>的一个过程，这一过程使得具有相同标签的像素具有某种共同视觉特性。</p><h2 id="1-2-原理及其主要公式"><a href="#1-2-原理及其主要公式" class="headerlink" title="1.2 原理及其主要公式"></a>1.2 原理及其主要公式</h2><h3 id="1-2-1-分水岭算法基本原理"><a href="#1-2-1-分水岭算法基本原理" class="headerlink" title="1.2.1 分水岭算法基本原理"></a>1.2.1 分水岭算法基本原理</h3><p>分水岭分割是基于自然的启发算法来模拟水流通过地形起伏的现象从而研究总结出来的一种分割方法，其基本原理是将图像特征看作地理上的地貌特征，利用像素的灰度值分布特征，对每个符合特征的区域进行划分，形成边界以构成分水岭。</p><p>水位不断上升，汇水盆地之间及其与背景之间的坝也越来越长。构筑水坝的目的是阻止盆地之间及其与背景之间的水汇聚。该过程一直持续，直到到达水的最高水位。最终水坝就是我们希望的分割结果。它的一条重要性质就是水坝组成一条连通的路径，这样，在两个区域之间就给出了连续的边界。</p><p>因为灰度变化较小的区域有较小的梯度值，因此，分水岭分割通常用于一幅图像的梯度，而不是图像本身。这样，汇水盆地的区域最小值就能很好地与待分割区域的较小梯度值联系起来。</p><p><img src="https://s1.ax1x.com/2020/04/03/Ga7GIP.jpg" alt="图1-1 原图及图像"></p><p>在上面的水岭算法示意图中局部极小值、积水盆地，分水岭线以及水坝的概念可以描述为：</p><p>（1）区域极小值：导数为0的点，局部范围内的最小值点；</p><p>（2）集水盆（汇水盆地）：当“水”落到汇水盆地时，“水”会自然而然地流到汇水盆地中的区域极小值点处。每一个汇水盆地中有且仅有一个区域极小值点；</p><p>（3）分水岭：当“水”处于分水岭的位置时，会等概率地流向多个与它相邻的汇水盆地中；</p><p>（4）水坝：人为修建的分水岭，防止相邻汇水盆地之间的“水”互相交汇影响</p><p>分水岭计算方法被分为两个步骤，分别是排序过程和淹没过程。计算时，首先要按照从低到高的排序方式对区域内的每个像素进行灰度级别的排序，然后在从低到高进行淹没，并对每个区域极小值在 H 阶高度的影响域采用先进先出的结构进行标注和判断。通过分水岭的变换所得到输入图像为集水盆图像，每个集水盆之间的边界就是分水岭，而分水岭则代表极大值，所以想要获取图像的信息，需要将梯度图像作为输入图像进行计算，计算公式如下：</p><p><img src="https://s1.ax1x.com/2020/04/03/Ga78at.png" alt="（式1.1）"> </p><p>在该计算公式中 <em>f(x,y)</em> 则代表原始图像，<em>grad{.}</em> 则代表梯度运算。</p><h3 id="1-2-2-目标计数基本原理"><a href="#1-2-2-目标计数基本原理" class="headerlink" title="1.2.2 目标计数基本原理"></a>1.2.2 目标计数基本原理</h3><p>本文使用的目标计数原理是基于Matlab中的bwboundaries函数实现的。bwboundaries是一个函数，可以用来获取二值图中对象的轮廓，包括外部轮廓与内部边缘。</p><p>[B,L,N]=bwboundaries(show_img,’noholes’);</p><p>使用上面的语句来获取图像连通区域并求取其轮廓。其中N为物体目标的个数。在使用该函数之前，首先要对原图像进行中值滤波操作去除图像中的噪声；然后进行二值化操作，来将目标物体提取出来；之后再针对目标物体有交叉重叠部分的图像，采用分水岭算法来进行图像分割；最后使用bwboundaries函数，来通过计算目标物体的连通域个数，最终计算出目标物体的数目。</p><p>在实验的过程中，通过计算每个目标的连通域的中心位置，还对每个目标进行了标号，来标记每个物体的位置。实验效果图见图1-2。</p><h2 id="1-3-实验结果"><a href="#1-3-实验结果" class="headerlink" title="1.3 实验结果"></a>1.3 实验结果</h2><p>通过运行分水岭图像分割方法，对三张图片进行了图像分割与物体计数。得到的结果图下图1-1到图1-6所示。其中图1-1的a图为原始图像，图1-1的b图为进行图像分割后的图像；计算得到的三个物体数目分别是48个、10个以及97个。</p><p><img src="https://s1.ax1x.com/2020/04/03/GaH60A.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/04/03/GabG38.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/04/03/GaHymd.png" alt=""></p><h5 id="详细代码及文件下载地址："><a href="#详细代码及文件下载地址：" class="headerlink" title="详细代码及文件下载地址："></a>详细代码及文件下载地址：</h5><p>链接： <a href="https://www.lanzous.com/ib739mh" target="_blank" rel="noopener">https://www.lanzous.com/ib739mh</a> </p>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[无人机-开发总结04]-构建无人机状态转移模型</title>
      <link href="/2020/04/03/wu-ren-ji-kai-fa-zong-jie-04-gou-jian-wu-ren-ji-zhuang-tai-zhuan-yi-mo-xing/"/>
      <url>/2020/04/03/wu-ren-ji-kai-fa-zong-jie-04-gou-jian-wu-ren-ji-zhuang-tai-zhuan-yi-mo-xing/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1飞控网络"><a href="#1飞控网络" class="headerlink" title="1飞控网络"></a>1飞控网络</h1><h2 id="1-1-问题分析"><a href="#1-1-问题分析" class="headerlink" title="1.1   问题分析"></a>1.1   问题分析</h2><p>搭建一个能用来表达飞控模型的网络。具体原理就是：通过当前时刻飞机的状态，当给飞机施加一定的作用力时，来预测飞机下一时刻所处的状态。</p><h2 id="1-2-网络结构"><a href="#1-2-网络结构" class="headerlink" title="1.2   网络结构"></a>1.2   网络结构</h2><p>网络结构：两个LSTM网络加一个全连接层</p><p><img src="https://s1.ax1x.com/2020/04/03/GahXs1.png" alt="图1-1 网络结构图及数据类型"></p><h2 id="1-3-准备数据集"><a href="#1-3-准备数据集" class="headerlink" title="1.3   准备数据集"></a>1.3   准备数据集</h2><p>通过对问题的分析，我们使用了里程计采集的位置信息（x、y、z三个维度）、IMU的角速度、线加速度以及姿态角的四元数、GPS的维度、经度和海拔和执行的动作量（四个电机的速度）来作为网络的输入；然后来预测下一时刻飞机的所有状态，数据集具体格式如下所示：</p><p><strong>网络输入数据：</strong></p><p>维度：21维</p><p>当前时刻里程计位置数据: pos(t)</p><p>当前时刻Imu数据: Imu_angular_1*3(t)、</p><p>​     Imu_linear_acc_1<em>3(t)、Imu_orientation_1</em>4(t)</p><p>当前时刻GPS数据: latitude(t)、 longitude(t)、attitude(t)</p><p>当前时刻执行的动作量: motor_vel(t)</p><p><strong>网络输出数据：</strong></p><p>维度：17维</p><p>下一时刻里程计位置数据: pos(t+1)</p><p>下一时刻Imu数据: Imu_angular_1*3(t+1)</p><p> Imu_linear_acc_1<em>3(t+1)、 Imu_orientation_1</em>4(t+1)</p><p>下一时刻GPS数据:</p><p> latitude(t+1)、 longitude(t+1)、attitude(t+1)</p><p><img src="https://s1.ax1x.com/2020/04/03/GahOMR.png" alt="图1-2数据集"></p><h2 id="1-4-训练过程"><a href="#1-4-训练过程" class="headerlink" title="1.4   训练过程"></a>1.4   训练过程</h2><p>（1）   一开始我们只使用一个单层LSTM网络，（悬停与着陆数据集）进行训练后损失曲线如下图：</p><p><img src="https://s1.ax1x.com/2020/04/03/Gahqz9.png" alt="图1-3 损失变化曲线"></p><p>（2）   改用一个两层的LSTM网络加一层全连接网络（悬停与着陆数据集），进行训练后损失曲线如下图：</p><p><img src="https://s1.ax1x.com/2020/04/03/GahbRJ.png" alt="图1-4 损失变化曲线"></p><p>训练集损失</p><p>train_loss:</p><p>[0.5328224748931825, 0.26620951036922635, 0.19988369228783995, 0.18238666167017073, 0.15780297216959296, 0.13405323654878884, 0.11955312862759455, 0.12240861531812698, 0.11148360138759017, 0.10631599110318347, 0.09910413057776168, 0.049408715929603206, 0.04769245133502409, 0.04726856110850349, 0.04721733894082718, 0.0468275742395781, 0.04609204622916877, 0.04590331030194648, 0.04610561237088404,     0.04580454896437004]</p><p>验证集损失</p><p>valid_loss:</p><p>[0.2610532984137535, 0.21840908512473106, 0.12710216868668794, 0.13170075602829456, 0.10646352278068662, 0.10994287248700857, 0.10560724565759301, 0.09868648458272218, 0.08157385680824518, 0.09954582054167986, 0.045364946499466895, 0.045166648412123325, 0.04495138650760055,      0.04579222447238863,     0.04504713535308838,</p><p>0.04317425129935146, 0.0432081026956439, 0.0428824489749968, 0.042863981537520884,     0.04279392964206636]</p><p>测试集损失</p><p>test_loss:</p><p> [0.04178078664466739]</p><p>（3）   通过进一步调整网络结构，我们得到由一个两层的LSTM网络加一层全连接网络来进行训练（随机飞行数据集），损失曲线如下图：</p><p><img src="https://s1.ax1x.com/2020/04/03/GahHG4.png" alt="图1-5 损失变化曲线"></p><p>训练集损失</p><p>train_loss:</p><p>[5.54658406406641, 2.7655773708224296, 1.9791212353110312, 1.9600225511938334, 1.6933349587023259, 1.625489605218172, 1.508753139078617, 1.5195634232461452, 1.3797193969041108, 1.3643508572131395, 1.291658177152276, 0.7853003278374672, 0.7368028278648854, 0.7272456296905875, 0.7046212753653527, 0.6962497440353036, 0.6476068877056241, 0.6371722454577684, 0.6312894182279706, 0.6313313307613134]</p><p>验证集损失</p><p>valid_loss:</p><p>[4.110855451822281, 2.306476159095764, 1.9303114801645278, 2.1317190492153166, 1.668769862651825, 1.6565870666503906, 1.7624870729446411, 1.4876971435546875, 1.4524815315008164, 1.562660975754261, 1.183311020731926, 0.6977832567691803, 0.6980695559084416, 0.6902341730892658, 0.6989173652231693, 0.6376479545235634, 0.6043669553101063, 0.6014045214653015, 0.6008586919307709, 0.598616446107626]</p><p>测试集损失</p><p>test_loss:</p><p>[0.46288112133741377]</p><h2 id="1-5-预测结果"><a href="#1-5-预测结果" class="headerlink" title="1.5   预测结果"></a>1.5   预测结果</h2><p>（1）使用悬停数据集来进行预测</p><p>-——————————</p><p>预测值：0.131</p><p>真实值：0.131</p><p>-——————————</p><p>预测值：-0.007</p><p>真实值：-0.007</p><p>-——————————</p><p>预测值：2.952</p><p>真实值：2.940</p><p>-——————————</p><p>预测值：0.001</p><p>真实值：-0.001</p><p>-——————————</p><p>预测值：0.005</p><p>真实值：0.006</p><p>-——————————</p><p>预测值：-0.000</p><p>真实值：0.002</p><p>-——————————</p><p>预测值：0.000</p><p>真实值：0.000</p><p>-——————————</p><p>预测值：-0.265</p><p>真实值：-0.354</p><p>-——————————</p><p>预测值：-0.118</p><p>真实值：-0.214</p><p>-——————————</p><p>预测值：0.000</p><p>真实值：0.000</p><p>-——————————</p><p>预测值：0.000</p><p>真实值：0.000</p><p>-——————————</p><p>预测值：0.000</p><p>真实值：0.000</p><p>-——————————</p><p>预测值：1.000</p><p>真实值：1.000</p><p>-——————————</p><p>预测值：41.766</p><p>真实值：41.766</p><p>-——————————</p><p>预测值：73.984</p><p>真实值：73.984</p><p>-——————————</p><p>预测值：53.121</p><p>真实值：53.110</p><p>-——————————</p><p>预测值：100690.562</p><p>真实值：100690.641</p><p>（2）使用随机飞行数据集来进行预测</p><p>-——————————</p><p>预测值：1.294</p><p>真实值：1.203</p><p>-——————————</p><p>预测值：0.647</p><p>真实值：0.292</p><p>-——————————</p><p>预测值：10.323</p><p>真实值：10.529</p><p>-——————————</p><p>预测值：0.001</p><p>真实值：-0.463</p><p>-——————————</p><p>预测值：0.006</p><p>真实值：-1.134</p><p>-——————————</p><p>预测值：-0.002</p><p>真实值：-0.054</p><p>-——————————</p><p>预测值：0.000</p><p>真实值：0.000</p><p>-——————————</p><p>预测值：-0.095</p><p>真实值：-0.546</p><p>-——————————</p><p>预测值：-0.222</p><p>真实值：0.034</p><p>-——————————</p><p>预测值：-0.001</p><p>真实值：0.078</p><p>-——————————</p><p>预测值：0.010</p><p>真实值：0.111</p><p>-——————————</p><p>预测值：0.001</p><p>真实值：0.004</p><p>-——————————</p><p>预测值：0.983</p><p>真实值：-0.991</p><p>-——————————</p><p>预测值：41.766</p><p>真实值：41.766</p><p>-——————————</p><p>预测值：73.984</p><p>真实值：73.984</p><p>-——————————</p><p>预测值：60.173</p><p>真实值：59.991</p><p>-——————————</p><p>预测值：100601.930</p><p>真实值：100604.977</p><iframe height=560 width=800 src="//player.bilibili.com/player.html?aid=625192323&bvid=BV1it4y1U77C&cid=176170958&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
      
      
      <categories>
          
          <category> 开发总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无人机开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Matlab使用-课程学习]-用遗传算法求解TSP问题</title>
      <link href="/2020/03/23/matlab-shi-yong-ke-cheng-xue-xi-yong-yi-chuan-suan-fa-qiu-jie-tsp-wen-ti/"/>
      <url>/2020/03/23/matlab-shi-yong-ke-cheng-xue-xi-yong-yi-chuan-suan-fa-qiu-jie-tsp-wen-ti/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Matlab环境下使用遗传算法求解TSP问题"><a href="#Matlab环境下使用遗传算法求解TSP问题" class="headerlink" title="Matlab环境下使用遗传算法求解TSP问题"></a>Matlab环境下使用遗传算法求解TSP问题</h1><p><strong>摘要：</strong>遗传算法(genetic algorithm (GA))是<a href="https://zh.wikipedia.org/wiki/计算数学" target="_blank" rel="noopener">计算数学</a>中用于解决<a href="https://zh.wikipedia.org/wiki/最佳化" target="_blank" rel="noopener">最优化</a>的搜索<a href="https://zh.wikipedia.org/wiki/算法" target="_blank" rel="noopener">算法</a>，是<a href="https://zh.wikipedia.org/wiki/进化算法" target="_blank" rel="noopener">进化算法</a>的一种。而旅行商问题（travelling salesman problem, TSP）是<a href="https://zh.wikipedia.org/wiki/组合优化" target="_blank" rel="noopener">组合优化</a>中的一个<a href="https://zh.wikipedia.org/wiki/NP困难" target="_blank" rel="noopener">NP困难</a>问题。它可以描述为给定一系列城市和每对城市之间的距离，求解访问每一座城市一次并回到起始城市的最短回路。本文利用Matlab工具，通过使用遗传算法来求解TSP问题，来计算通过多个城市之间的最优路径与最短距离。</p><p><strong>关键词：</strong>遗传算法；TSP问题；组合优化；Matlab</p><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​        对于求解<em>n</em>个城市的TSP问题，存在(<em>n</em>-1)!条闭合路径的排列方案，因此 TSP问题是一个典型的NP完全问题。对于这类问题很难用全局搜索法精确地求出其最优解，因此研究相应的有效算法寻找其最优或近似最优解具有重要的理论意义。另外，很多实际实用的问题，如印刷电路板的钻孔路线方案、连锁店的货物配送路线等经过简化处理后，均可建模为旅行商问题，因此对旅行商问题求解方法的研究也具有重要的实用价值。目前求解TSP问题的主要方法有启发式搜索法、模拟退火算法、遗传算法、神经网络算法及二叉树描述算法，其中遗传算法是求解此类NP完全问题的一种比较有效的全局搜索方法[1]。 </p><p>​        本文首先在第二章介绍了TSP问题的概念以及数学模型；然后在第三章介绍了一下遗传算法的基本原理；最后在第四章在Matlab环境下，通过遗传算法来实现对多组城市的TSP平问题进行求解，来对遗传算法的性能进行了测试。最后对遗传算法的性能进行了简单的分析。</p><h2 id="2-TSP旅行商问题"><a href="#2-TSP旅行商问题" class="headerlink" title="2 TSP旅行商问题"></a>2 TSP旅行商问题</h2><h3 id="2-1-旅行商问题（TSP）描述"><a href="#2-1-旅行商问题（TSP）描述" class="headerlink" title="2.1 旅行商问题（TSP）描述"></a>2.1 旅行商问题（TSP）描述</h3><p>旅行商问题（Travelling salesman problem, TSP）：它是给定一系列城市和每对城市之间的距离，求解访问每一座城市一次并回到起始城市的最短回路。它是<a href="https://zh.wikipedia.org/wiki/组合优化" target="_blank" rel="noopener">组合优化</a>中的一个<a href="https://zh.wikipedia.org/wiki/NP困难" target="_blank" rel="noopener">NP困难</a>问题，在<a href="https://zh.wikipedia.org/wiki/运筹学" target="_blank" rel="noopener">运筹学</a>和<a href="https://zh.wikipedia.org/wiki/理論計算機科學" target="_blank" rel="noopener">理论计算机科学</a>中非常重要。如图2-1所示。</p><p><img src="https://pic.downk.cc/item/5e78b18e9dbe9d88c5599895.png" alt="图 2-1旅行商的解">       </p><p>本文主要通过遗传算法来解决TSP问题。该TSP问题可以简要概括为：事先已经获得了多组城市的位置信息（<em>x</em>和<em>y</em>）。通过计算每个城市之间的距离，利用遗传算法来得到一条从起始城市开始运动，不重复地经过每一个城市，最终再回到起始城市的最优路径，并计算出最优行驶距离。</p><h3 id="2-2-旅行商问题（TSP）数学模型"><a href="#2-2-旅行商问题（TSP）数学模型" class="headerlink" title="2.2 旅行商问题（TSP）数学模型"></a>2.2 旅行商问题（TSP）数学模型</h3><p>它的数学模型可以总结如下：</p><p>设有<em>n</em>个城市,它们的位置坐标为： {( <em>x</em>1 ,<em>y</em>1),( <em>x</em>2 ,<em>y</em>2),(<em>x</em>3,<em>y</em>3) ,… , (<em>x</em>n,<em>y</em>n)}。</p><p>从<em>n</em>个城市中随机选择一个城市作为起点，然后依次不重复地经过n座城市,最终返回起点。则该TSP问题的路径长度可以表示为：<br>$$<br>d_{min}=\sqrt[1/2]{\sum_{i=1}^{n-1}{(x_i-x_{i+1})^2+(y_i-y_{i+1})^2}} \tag {2.1}<br>$$<br>TSP是<a href="https://zh.wikipedia.org/w/index.php?title=旅行购买者问题&action=edit&redlink=1" target="_blank" rel="noopener">旅行购买者问题</a>与<a href="https://zh.wikipedia.org/wiki/车辆路径问题" target="_blank" rel="noopener">车辆路径问题</a>的一种特殊情况。TSP问题在1930年首次被形式化，并且是在最优化中研究最深入的问题之一。许多优化方法都用它作为一个基准。尽管问题在计算上很困难，但已经有了大量的<a href="https://zh.wikipedia.org/wiki/启发式" target="_blank" rel="noopener">启发式</a>和精确方法，因此可以完全求解城市数量上万的实例，并且甚至能在误差1%范围内估计上百万个城市的问题[2]。但是，求解TSP算法的<a href="https://zh.wikipedia.org/w/index.php?title=运行时间&action=edit&redlink=1" target="_blank" rel="noopener">时间复杂度</a>会随着城市数量的增多而成<a href="https://zh.wikipedia.org/w/index.php?title=指数时间假说&action=edit&redlink=1" target="_blank" rel="noopener">指数</a>级别增长。</p><h2 id="3-遗传算法"><a href="#3-遗传算法" class="headerlink" title="3 遗传算法"></a>3 遗传算法</h2><h3 id="3-1-遗传算法简介"><a href="#3-1-遗传算法简介" class="headerlink" title="3.1 遗传算法简介"></a>3.1 遗传算法简介</h3><p>  遗传算法由<a href="https://zh.wikipedia.org/wiki/密歇根大学" target="_blank" rel="noopener">密歇根大学</a>的<a href="https://zh.wikipedia.org/wiki/约翰·霍兰德" target="_blank" rel="noopener">约翰·霍兰德</a>和他的同事于二十世纪六十年代在对<a href="https://zh.wikipedia.org/wiki/細胞自動機" target="_blank" rel="noopener">细胞自动机</a>（cellular automata）进行研究时率先提出[3]。在二十世纪八十年代中期之前，对于遗传算法的研究还仅仅限于理论方面，直到在<a href="https://zh.wikipedia.org/wiki/匹兹堡" target="_blank" rel="noopener">匹兹堡</a>召开了第一届<a href="https://zh.wikipedia.org/w/index.php?title=世界遗传算法大会&action=edit&redlink=1" target="_blank" rel="noopener">世界遗传算法大会</a>。随着计算机计算能力的发展和实际应用需求的增多，遗传算法逐渐进入实际应用阶段。1989年，<a href="https://zh.wikipedia.org/wiki/纽约时报" target="_blank" rel="noopener">纽约时报</a>作者<a href="https://zh.wikipedia.org/w/index.php?title=约翰·马科夫&action=edit&redlink=1" target="_blank" rel="noopener">约翰·马科夫</a>写了一篇文章描述第一个商业用途的遗传算法–<a href="https://zh.wikipedia.org/w/index.php?title=进化者&action=edit&redlink=1" target="_blank" rel="noopener">进化者</a>（英文：Evolver）。之后，越来越多种类的遗传算法出现并被用于许多领域中，<a href="https://zh.wikipedia.org/wiki/财富杂志" target="_blank" rel="noopener">财富杂志</a>500强企业中大多数都用它进行时间表安排、数据分析、未来趋势预测、预算、以及解决很多其他组合优化问题。</p><p>遗传算法(genetic algorithm (GA))是<a href="https://zh.wikipedia.org/wiki/计算数学" target="_blank" rel="noopener">计算数学</a>中用于解决<a href="https://zh.wikipedia.org/wiki/最佳化" target="_blank" rel="noopener">最优化</a>的搜索<a href="https://zh.wikipedia.org/wiki/算法" target="_blank" rel="noopener">算法</a>，是<a href="https://zh.wikipedia.org/wiki/进化算法" target="_blank" rel="noopener">进化算法</a>的一种。进化算法最初是借鉴了<a href="https://zh.wikipedia.org/wiki/进化生物学" target="_blank" rel="noopener">进化生物学</a>中的一些现象而发展起来的，这些现象包括<a href="https://zh.wikipedia.org/wiki/遗传" target="_blank" rel="noopener">遗传</a>、<a href="https://zh.wikipedia.org/wiki/突变" target="_blank" rel="noopener">突变</a>、<a href="https://zh.wikipedia.org/wiki/自然选择" target="_blank" rel="noopener">自然选择</a>以及<a href="https://zh.wikipedia.org/wiki/杂交" target="_blank" rel="noopener">杂交</a>等。</p><p>遗传算法通常实现方式为一种<a href="https://zh.wikipedia.org/wiki/计算机模拟" target="_blank" rel="noopener">计算机模拟</a>。对于一个最优化问题，一定数量的<a href="https://zh.wikipedia.org/w/index.php?title=候选解&action=edit&redlink=1" target="_blank" rel="noopener">候选解</a>（称为个体）可抽象表示为<a href="https://zh.wikipedia.org/wiki/染色體_(遺傳演算法)" target="_blank" rel="noopener">染色体</a>，使<a href="https://zh.wikipedia.org/wiki/种群" target="_blank" rel="noopener">种群</a>向更好的解进化。传统上，解用<a href="https://zh.wikipedia.org/wiki/二进制" target="_blank" rel="noopener">二进制</a>表示（即0和1的串），但也可以用其他表示方法。进化从完全<a href="https://zh.wikipedia.org/wiki/随机" target="_blank" rel="noopener">随机</a>个体的种群开始，之后一代一代发生。在每一代中评价整个种群的<a href="https://zh.wikipedia.org/wiki/适应度" target="_blank" rel="noopener">适应度</a>，从当前种群中随机地选择多个个体（基于它们的适应度），通过自然选择和突变产生新的生命种群，该种群在算法的下一次迭代中成为当前种群。</p><h3 id="3-2-遗传算法的构成要素"><a href="#3-2-遗传算法的构成要素" class="headerlink" title="3.2 遗传算法的构成要素"></a>3.2 遗传算法的构成要素</h3><h4 id="3-2-1-编码与解码"><a href="#3-2-1-编码与解码" class="headerlink" title="3.2.1 编码与解码"></a>3.2.1 编码与解码</h4><p>在遗传算法里，优化问题的解被称为个体，它表示为一个变量序列，叫做<a href="https://zh.wikipedia.org/wiki/染色體_(遺傳演算法)" target="_blank" rel="noopener">染色体</a>或者<a href="https://zh.wikipedia.org/wiki/基因" target="_blank" rel="noopener">基因</a><a href="https://zh.wikipedia.org/wiki/字符串" target="_blank" rel="noopener">串</a>。染色体一般被表达为简单的字符串或数字符串，不过也有其他的依赖于特殊问题的表示方法适用，这一过程称为编码。</p><p>首先，算法<a href="https://zh.wikipedia.org/wiki/随机函数" target="_blank" rel="noopener">随机</a>生成一定数量的个体，有时候操作者也可以干预这个随机产生过程，以提高初始种群的质量。在每一代中，都会评价每一个体，并通过计算<a href="https://zh.wikipedia.org/w/index.php?title=适应度函数&action=edit&redlink=1" target="_blank" rel="noopener">适应度函数</a>得到<a href="https://zh.wikipedia.org/wiki/适应度" target="_blank" rel="noopener">适应度</a>数值。按照适应度<a href="https://zh.wikipedia.org/wiki/排序" target="_blank" rel="noopener">排序</a>种群个体，适应度高的在前面。这里的“高”是相对于初始的种群的低适应度而言。</p><h4 id="3-2-2-适应度计算"><a href="#3-2-2-适应度计算" class="headerlink" title="3.2.2 适应度计算"></a>3.2.2 适应度计算</h4><p>适应度（Fitness），又可称适存度，是<a href="https://zh.wikipedia.org/wiki/生物學" target="_blank" rel="noopener">生物学</a>，特别是<a href="https://zh.wikipedia.org/wiki/群體遺傳學" target="_blank" rel="noopener">群体遗传学</a>、<a href="https://zh.wikipedia.org/wiki/數理生物學" target="_blank" rel="noopener">数理生物学</a>中用来描述拥有某一特定<a href="https://zh.wikipedia.org/wiki/基因型" target="_blank" rel="noopener">基因型</a>的<a href="https://zh.wikipedia.org/wiki/個體" target="_blank" rel="noopener">个体</a>，在<a href="https://zh.wikipedia.org/wiki/繁殖" target="_blank" rel="noopener">繁殖</a>上的成功率或能力。假如带有不同基因型的个体拥有不同的适应度，那么这些基因型的比例将会在世代交替之后有所变动。而造成这种比例变动的机制是<a href="https://zh.wikipedia.org/wiki/自然選擇" target="_blank" rel="noopener">自然选择</a>。</p><p>遗传算法依据原则：适应度越高，被选择的机会越高，而适应度低的，被选择的机会就低。但是，并不不意味着完全以适应度高低为导向，因为单纯选择适应度高的个体将可能导致算法快速收敛到局部最优解而非全局最优解。因此，它还会通过<a href="https://zh.wikipedia.org/wiki/繁殖" target="_blank" rel="noopener">繁殖</a>完成，其中繁殖包括交配（crossover，交叉操作）和变异（mutation）。</p><h4 id="3-2-3-交叉"><a href="#3-2-3-交叉" class="headerlink" title="3.2.3 交叉"></a>3.2.3 交叉</h4><p>交叉（crossover）是<a href="https://zh.wikipedia.org/wiki/遗传算法" target="_blank" rel="noopener">遗传算法</a>中由<a href="https://zh.wikipedia.org/wiki/遗传学" target="_blank" rel="noopener">遗传学</a>中<a href="https://zh.wikipedia.org/wiki/染色体" target="_blank" rel="noopener">染色体</a><a href="https://zh.wikipedia.org/w/index.php?title=交叉互换&action=edit&redlink=1" target="_blank" rel="noopener">交叉互换</a>、生物<a href="https://zh.wikipedia.org/wiki/杂交" target="_blank" rel="noopener">杂交</a>等现象发展来的一个<a href="https://zh.wikipedia.org/wiki/算法" target="_blank" rel="noopener">算法</a><a href="https://zh.wikipedia.org/w/index.php?title=过程_(计算机)&action=edit&redlink=1" target="_blank" rel="noopener">过程</a>，相当于生物学中的基因重组。交叉操作是遗传算法的核心部分。</p><p>杂交操作就是将两个父本染色体上的基因进行重新组合分配，从而产生下一代个体的过程，通过杂交可能会将两个父本的优势基因组合在一起，产生适应度更高、更接近最优解的新个体。通常杂交算法和基因的编码方式有关，当前采用最多的是二进制编码方式，二进制编码的主要杂交算法有：单点交叉、多点交叉以及均匀交叉等。</p><p>一般的遗传算法都有一个交配概率（又称为交叉概率），范围一般是0.6~1，这个交配概率反映两个被选中的个体进行交配的<a href="https://zh.wikipedia.org/wiki/概率" target="_blank" rel="noopener">概率</a>。例如，交配概率为0.8，则80%的“夫妻”会生育后代。每两个个体通过交配产生两个新个体，代替原来的“老”个体，而不交配的个体则保持不变。交配父母的染色体相互交换，从而产生两个新的染色体，第一个个体前半段是父亲的染色体，后半段是母亲的，第二个个体则正好相反。不过这里的半段并不是真正的一半，这个位置叫做交配点，也是随机产生的，可以是染色体的任意位置。</p><h4 id="3-2-4-变异"><a href="#3-2-4-变异" class="headerlink" title="3.2.4 变异"></a>3.2.4 变异</h4><p>在<a href="https://zh.wikipedia.org/wiki/遗传算法" target="_blank" rel="noopener">遗传算法</a>里面，变异是用来维持算法里面，族群（population）里面每一个世代的<a href="https://zh.wikipedia.org/wiki/染色體_(遺傳演算法)" target="_blank" rel="noopener">染色体</a>到下一个世代时，还能够维持<a href="https://zh.wikipedia.org/wiki/遺傳多樣性" target="_blank" rel="noopener">遗传多样性</a>的一个<a href="https://zh.wikipedia.org/wiki/遺傳運算元" target="_blank" rel="noopener">遗传算子</a>（genetic operator）。这个算子设计上相当于生物学方面的<a href="https://zh.wikipedia.org/wiki/突變" target="_blank" rel="noopener">突变</a>。</p><p>通过突变产生新的“子”个体。一般遗传算法都有一个固定的<a href="https://zh.wikipedia.org/w/index.php?title=突变常数&action=edit&redlink=1" target="_blank" rel="noopener">突变常数</a>（又称为变异概率），通常是0.1或者更小，这代表变异发生的概率。根据这个概率，新个体的染色体随机的突变，通常就是改变染色体的一个字节（0变到1，或者1变到0）。</p><p>遗传算法里面突变的目的在于维持并且提升多样性。突变应该要能够借由避免让族群里的染色体过于相近，来防范算法掉入<a href="https://zh.wikipedia.org/wiki/极值" target="_blank" rel="noopener">区域极值</a>，因此减慢或者停止进化过程。相同的理由也可以用来解释为何大多数遗传算法的系统避免只使用<a href="https://zh.wikipedia.org/w/index.php?title=適應函數&action=edit&redlink=1" target="_blank" rel="noopener">最适合</a>的染色体来产生下一代 ，而是在一些比较适合的里面随机（或者半随机）的选择出一些来产生下一代。</p><h4 id="3-2-5-终止条件"><a href="#3-2-5-终止条件" class="headerlink" title="3.2.5 终止条件"></a>3.2.5 终止条件</h4><p>遗传算法通过循环执行选择和繁殖操作，来不断寻找最优解，直到满足终止条件时结束循环。它的终止条件有以下几种：</p><p>（1）进化次数限制；</p><p>（2）计算耗费的资源限制（例如计算时间、计算占用的内存等）；</p><p>（3）一个个体已经满足最优值的条件，即最优值已经找到；</p><p>（4）适应度已经达到饱和，继续进化不会产生适应度更好的个体；</p><p>（5）人为干预；</p><p>（6）以及以上两种或更多种的组合。</p><h3 id="3-3-遗传算法基本流程"><a href="#3-3-遗传算法基本流程" class="headerlink" title="3.3 遗传算法基本流程"></a>3.3 遗传算法基本流程</h3><p>经过这一系列的过程（选择、交配和突变），产生的新一代个体不同于初始的一代，并一代一代向增加整体适应度的方向发展，因为总是更常选择最好的个体产生下一代，而适应度低的个体逐渐被淘汰掉。这样的过程不断的重复：评价每个个体，计算适应度，两两交配，然后突变，产生第三代。周而复始，直到终止条件满足为止[5]。遗传算法的基本流程可以总结为：</p><p>1）首先选择初始生命种群</p><p>2）评价种群中的个体适应度</p><p>3）以比例原则（分数高的挑中几率也较高）选择产生下一个种群（<a href="https://zh.wikipedia.org/w/index.php?title=輪盤法&action=edit&redlink=1" target="_blank" rel="noopener">轮盘法</a>（roulette wheel selection）。不仅仅挑分数最高的的原因是这么做可能收敛到局部的最佳点，而非整体的。</p><p>5）通过交叉和变异来更新该种群个体</p><p>6）直到满足终止条件停止遗传算法的执行。</p><p>其整体基本流程图如图3-1所示：</p><p><img src="https://pic.downk.cc/item/5e78bf299dbe9d88c560c521.png" alt="图3-1 遗传算法基本流程图"></p><h2 id="4-遗传算法求解TSP问题"><a href="#4-遗传算法求解TSP问题" class="headerlink" title="4 遗传算法求解TSP问题"></a>4 遗传算法求解TSP问题</h2><h3 id="4-1-TSP问题求解"><a href="#4-1-TSP问题求解" class="headerlink" title="4.1 TSP问题求解"></a>4.1 TSP问题求解</h3><p>本文通过遗传算法来求解包含<em>n</em>个城市（<em>n</em>=10,30,100）的TSP的最优解问题。</p><p>该TSP问题通过遗传算法来进行求解，需要执行以下步骤：</p><p>第一步是需要来初始化种群的每个染色体样本。在本文中，定义种群的大小为m。每个染色体的长度等于城市的数目n。每个染色体的值x是由每个城市的编号（1~n）随机排列组成。如：<em>x</em>i = {1, 2 , 5 , 3, 7 , 9, 10 , 6 , 4, 8} 。</p><p>第二步是来计算每条行驶路径，将行驶路径长度的倒数作为该个体的适应度。即距离越短，适应度越大。在程序实现过程，我所采取的的适应度计算方法是：<br>$$<br>f(x_i)=(\frac{1}{d})^{15}<br>  \tag{4.1}<br>$$<br>其中<em>d</em>为路径的总长度，<em>x</em>i为单个染色体，<em>f</em>为适应度函数。对距离求倒数后，又乘以15次方的原因是为了让好的个体被选取到的概率更大。因为适应度取距离的倒数后，若不乘上次方，则每个个体之间的适应度差别不大。这里的15也可以通过实验换成其他值。然后通过轮盘赌选择算法来对个体进行更新。适应度越高的个体，越容易被挑中，遗传到下一代。</p><p>第三步是通过交叉和变异操作来更新个体，需找最优解。在程序中，其中交叉操作采用的是随机交叉变异。首先，随机产生一个交叉的位置，然后在该位置处，将两个需要进行交叉变异的父代个体，从该位置开始到染色体末端交换编码信息，产生新的子代个体。而变异过程是在个体中找到两个需要变异的位置，将两者的信息进行交换，从而完成变异操作。</p><p>最后，直到满足停止条件（达到最大迭代次数），输出寻找到的最优路径和最短距离，整个程序结束。</p><h3 id="4-2-实验平台"><a href="#4-2-实验平台" class="headerlink" title="4.2 实验平台"></a>4.2 实验平台</h3><p>本实验所采用的的实验平台是在Windows 10 操作系统上的Matlab 2018a 环境下实现的。通过使用Matlab语言，来实现遗传算法，并求解TSP问题。如图4-1所示，为该实验的实验平台。</p><p> <img src="https://pic.downk.cc/item/5e78bf299dbe9d88c560c528.png" alt="图 4-1 实验平台">    </p><h3 id="4-3-实验结果"><a href="#4-3-实验结果" class="headerlink" title="4.3 实验结果"></a>4.3 实验结果</h3><p>(1) 当城市数目n=10时，</p><p><img src="https://pic.downk.cc/item/5e78bf299dbe9d88c560c52f.png" alt="图 4-2a 仿真结果（n=10）"></p><p><img src="https://pic.downk.cc/item/5e78bf299dbe9d88c560c535.png" alt="图 4-2b 仿真结果（n=10）"></p><p>​    </p><p>最终当城市数目为10个时，遗传算法能够很好地找到一条最优的行驶路径，如图4-2(a)所示。图4-2（b）为遗传算法计算得到的最短路径随算法迭代次数变换的曲线。它充分地表明了醉着算法的不断迭代，最终能够得到一个最优的路径。图4-3 是遗传算法最终得到的最优路径、最短距离以及获得最优结果所迭代的次数。</p><p>(2) 当城市数目n=30时，</p><p><img src="https://pic.downk.cc/item/5e78c0a19dbe9d88c5618c2f.png" alt="图 4-4a 仿真结果（n=30）"></p><p><img src="https://pic.downk.cc/item/5e78c0a19dbe9d88c5618c35.png" alt="图 4-4b 仿真结果（n=30）"></p><p><img src="https://pic.downk.cc/item/5e78c0a19dbe9d88c5618c3d.png" alt="图 4-5 最优路径（n=30）"></p><p>最终当城市数目增加到30个时，遗传算法仍然能够找到一条最优的行驶路径，如图4-4(a)所示。图4-4（b）为遗传算法计算得到的最短路径随算法迭代次数变换的曲线。随着算法的不断迭代，获得的最短距离也越来越小。图4-5 是遗传算法最终得到的最优路径、最短距离以及获得最优结果所迭代的次数。</p><p>(3) 当城市数目n=100时，</p><p>当城市数目增加到100时，我将算法的迭代次数增加到了1000次，由图4-6(a)可知遗传算法仍然没有找到该问题的最优解。但是由图4-6(b)可知，路径的最优距离一直在随着迭代次数不断变小，表明了只要遗传算法的迭代次数足够大，最终一定能够得到一个比较接近于最优解的值。图4-7 是通过遗传算法得到的最优路径、最短距离以及获得最优结果所迭代的次数。</p><p><img src="https://pic.downk.cc/item/5e78c0a19dbe9d88c5618c43.png" alt="图 4-6 仿真结果（n=100) a"></p><p><img src="https://pic.downk.cc/item/5e78c0a19dbe9d88c5618c4d.png" alt="图 4-6 仿真结果（n=100)b"></p><p><img src="https://pic.downk.cc/item/5e78c18d9dbe9d88c56225ab.png" alt=""></p><p>（4）改变种群内个体数目为m = 50和100时，</p><p><img src="https://pic.downk.cc/item/5e78c18d9dbe9d88c56225b0.png" alt="图 4-8 改变种群染色体个数(m=50)"></p><p><img src="https://pic.downk.cc/item/5e78c18e9dbe9d88c56225b7.png" alt="图 4-8 改变种群染色体个数(m=100)"></p><p>当改变遗传算法的初始种群大小时（即进行遗传的个体的数目），通过对比图4-8（a）与图4-8（b）可知，随着增加种群内个体的数目，最终更容易得到TSP问题的最优解，得到更加有效的最优路径。这表明了初始种群内的个体数量很重要，如果初始种群数量过多，算法会占用大量系统资源；如果初始种群数量过少，算法很可能找不到最优解。</p><p>（5）改变基因突变的概率为mutate_rate = 0.05和0.5时，</p><p><img src="https://pic.downk.cc/item/5e78c18e9dbe9d88c56225bb.png" alt="图4-9(a) mutate_rate = 0.05"></p><p><img src="https://pic.downk.cc/item/5e78c18e9dbe9d88c56225c0.png" alt="图4-9(b)mutate_rate=0.5"></p><p>当改变遗传算法的基因突变的概率时，通过对比图4-9（a）与图4-9（b）的实验结果可知，当mutate_rate = 0.05时，得到的最短距离为17651；而当mutate_rate = 0.5时，最终得到的最短距离为14227。随着基因突变的概率增加，算法更容易得到全局最优解，避免算法陷入局部最优解。但是，如果基因突变的概率太大，算法的收敛速度将会变得很慢。</p><h3 id="4-4-本章小结"><a href="#4-4-本章小结" class="headerlink" title="4.4 本章小结"></a>4.4 本章小结</h3><p>通过上面的实验结果我们能够知道：随着城市数目的增加，遗传算法的计算复杂度也在呈指数形式增加。当城市数目较小时，遗传算法能够得到该TSP问题的最优解。但当城市数目太大时，只能不断提高算法的迭代次数，来提高最优解的质量。</p><p>对于任何一个具体的优化问题，调节遗传算法的参数可能会有利于更好更快收敛，这些参数包括个体数目、交叉率和变异率。例如太大的变异率会导致丢失最优解，而过小的变异率会导致算法过早的收敛于局部最优点。对于这些参数的选择，需要我们通过实验不断的进行尝试，或者将遗传算法与其他算法进行结合使用，来提高遗传算法的效率。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>本文首先讲解了TSP问题的基本概念及数学模型；之后又对遗传算法的基本原理进行了讲解。最后在Matlab环境中，通过对不同城市数目的多组数据来用遗传算法来进行最优解的计算。通过实验结果表明，在数据量不太多的情况下，遗传算法能够求得比较好的解。</p><h2 id="6-主程序"><a href="#6-主程序" class="headerlink" title="6  主程序"></a>6  主程序</h2><p>**</p><pre class=" language-matlab"><code class="language-matlab">``<span class="token comment" spellcheck="true">%Matlab****程序**``</span>`<span class="token operator">*</span><span class="token operator">*</span><span class="token comment" spellcheck="true">%** **main.m**`</span>`<span class="token comment" spellcheck="true">% 遗传算法求解TSP问题`</span>`clear<span class="token punctuation">;</span>``clear all<span class="token punctuation">;</span>``CityNum <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">% 城市数目，可以选 10, 30, 50, 75`</span>`<span class="token punctuation">[</span>dislist<span class="token punctuation">,</span> Clist<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">tsp</span><span class="token punctuation">(</span>CityNum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">% dislist 为城市之间相互的距离，Clist 为各城市的坐标`</span>```` `inn <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">% 初始种群大小`</span>`gnMax <span class="token operator">=</span> <span class="token number">500</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">% 最大代数`</span>`crossProb <span class="token operator">=</span> <span class="token number">0.8</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">% 交叉概率`</span>`muteProb <span class="token operator">=</span> <span class="token number">0.5</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">% 变异概率`</span>```` `<span class="token comment" spellcheck="true">% 随机产生初始种群`</span>`population <span class="token operator">=</span> <span class="token function">zeros</span><span class="token punctuation">(</span>inn<span class="token punctuation">,</span> CityNum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">% population 为初始种群，包括多条染色体`</span>`<span class="token keyword">for</span> <span class="token number">i</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">:</span> inn`  `<span class="token function">population</span><span class="token punctuation">(</span><span class="token number">i</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">randperm</span><span class="token punctuation">(</span>CityNum<span class="token punctuation">)</span><span class="token punctuation">;</span>``<span class="token keyword">end</span>``<span class="token punctuation">[</span><span class="token operator">~</span><span class="token punctuation">,</span> cumulativeProbs<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">calPopulationValue</span><span class="token punctuation">(</span>population<span class="token punctuation">,</span> dislist<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">% 计算种群每条染色体的累计概率`</span>```` `generationNum <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>``generationMeanValue <span class="token operator">=</span> <span class="token function">zeros</span><span class="token punctuation">(</span>generationNum<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">% 每一代的平均距离`</span>`generationMaxValue <span class="token operator">=</span> <span class="token function">zeros</span><span class="token punctuation">(</span>generationNum<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">% 每一代的最短距离`</span>`bestRoute <span class="token operator">=</span> <span class="token function">zeros</span><span class="token punctuation">(</span>inn<span class="token punctuation">,</span> CityNum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">% 最佳路径`</span>`newPopulation <span class="token operator">=</span> <span class="token function">zeros</span><span class="token punctuation">(</span>inn<span class="token punctuation">,</span> CityNum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">% 新的种群`</span>`<span class="token keyword">while</span> generationNum <span class="token operator">&lt;</span> gnMax <span class="token operator">+</span> <span class="token number">1</span>`  `<span class="token keyword">for</span> <span class="token number">j</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token operator">:</span> inn`   `selectedChromos <span class="token operator">=</span> <span class="token function">select</span><span class="token punctuation">(</span>cumulativeProbs<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">% 选择操作，选出两条需要交叉编译的染色体，即父亲母亲`</span>   `crossedChromos <span class="token operator">=</span> <span class="token function">cross</span><span class="token punctuation">(</span>population<span class="token punctuation">,</span> selectedChromos<span class="token punctuation">,</span> crossProb<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">% 交叉操作，返回交叉后的染色体`</span>   `<span class="token function">newPopulation</span><span class="token punctuation">(</span><span class="token number">j</span><span class="token punctuation">,</span> <span class="token operator">:</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">mut</span><span class="token punctuation">(</span><span class="token function">crossedChromos</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">:</span><span class="token punctuation">)</span><span class="token punctuation">,</span>muteProb<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">% 对交叉后的染色体进行变异操作`</span>   `<span class="token function">newPopulation</span><span class="token punctuation">(</span><span class="token number">j</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">:</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">mut</span><span class="token punctuation">(</span><span class="token function">crossedChromos</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">:</span><span class="token punctuation">)</span><span class="token punctuation">,</span> muteProb<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">% 对交叉后的染色体进行变异操作`</span>  `<span class="token keyword">end</span>`  `population <span class="token operator">=</span> newPopulation<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">%产生了新的种群`</span>  `<span class="token punctuation">[</span>populationValue<span class="token punctuation">,</span> cumulativeProbs<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">calPopulationValue</span><span class="token punctuation">(</span>population<span class="token punctuation">,</span> dislist<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">% 计算新种群的适应度`</span>  `<span class="token comment" spellcheck="true">% 记录当前代最好和平均的适应度`</span>  `<span class="token punctuation">[</span>fmax<span class="token punctuation">,</span> nmax<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>populationValue<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">% 因为计算适应度时取距离的倒数，这里面取最大的倒数，即最短的距离`</span>  `<span class="token function">generationMeanValue</span><span class="token punctuation">(</span>generationNum<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> <span class="token function">mean</span><span class="token punctuation">(</span>populationValue<span class="token punctuation">)</span><span class="token punctuation">;</span>`   `<span class="token function">generationMaxValue</span><span class="token punctuation">(</span>generationNum<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> fmax<span class="token punctuation">;</span>`    `bestChromo <span class="token operator">=</span> <span class="token function">population</span><span class="token punctuation">(</span>nmax<span class="token punctuation">,</span> <span class="token operator">:</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">% 前代最佳染色体，即对应的路径`</span>  `<span class="token function">bestRoute</span><span class="token punctuation">(</span>generationNum<span class="token punctuation">,</span> <span class="token operator">:</span><span class="token punctuation">)</span> <span class="token operator">=</span> bestChromo<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">% 记录每一代的最佳染色体`</span>  `<span class="token function">drawTSP</span><span class="token punctuation">(</span>Clist<span class="token punctuation">,</span> bestChromo<span class="token punctuation">,</span> <span class="token function">generationMaxValue</span><span class="token punctuation">(</span>generationNum<span class="token punctuation">)</span><span class="token punctuation">,</span> generationNum<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>`  `generationNum <span class="token operator">=</span> generationNum <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>``<span class="token keyword">end</span>``<span class="token punctuation">[</span>bestValue<span class="token punctuation">,</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>generationMaxValue<span class="token punctuation">)</span><span class="token punctuation">;</span>``<span class="token function">drawTSP</span><span class="token punctuation">(</span>Clist<span class="token punctuation">,</span> <span class="token function">bestRoute</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> <span class="token operator">:</span><span class="token punctuation">)</span><span class="token punctuation">,</span> bestValue<span class="token punctuation">,</span> index<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>````` `<span class="token function">figure</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>``<span class="token function">plot</span><span class="token punctuation">(</span>generationMaxValue<span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>` `hold on<span class="token punctuation">;</span>``<span class="token function">plot</span><span class="token punctuation">(</span>generationMeanValue<span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>` `grid<span class="token punctuation">;</span>``<span class="token function">title</span><span class="token punctuation">(</span><span class="token string">'搜索过程'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>``<span class="token function">legend</span><span class="token punctuation">(</span><span class="token string">'最优解'</span><span class="token punctuation">,</span> <span class="token string">'平均解'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>``<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token string">'遗传算法得到的最优迭代次数为: %d\n'</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>``<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token string">'遗传算法得到的最短距离: %.2f\n'</span><span class="token punctuation">,</span> bestValue<span class="token punctuation">)</span><span class="token punctuation">;</span>``<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token string">'遗传算法得到的最短路线:'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>``<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token string">'%d ->'</span><span class="token punctuation">,</span> <span class="token function">bestRoute</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>``<span class="token function">fprintf</span><span class="token punctuation">(</span>"<span class="token operator">\</span>n"<span class="token punctuation">)</span><span class="token punctuation">;</span>``<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token string">'%d ->'</span><span class="token punctuation">,</span> <span class="token function">bestRoute</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span><span class="token number">16</span><span class="token operator">:</span><span class="token keyword">end</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>``<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token string">'%d \n'</span><span class="token punctuation">,</span> <span class="token function">bestRoute</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>``` `` </code></pre><h5 id="详细代码及文件下载地址："><a href="#详细代码及文件下载地址：" class="headerlink" title="详细代码及文件下载地址："></a>详细代码及文件下载地址：</h5><p>链接：<a href="https://www.lanzous.com/ib73fub" target="_blank" rel="noopener">https://www.lanzous.com/ib73fub</a></p>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[树莓派-开发总结01]-可穿戴式智能设备</title>
      <link href="/2020/03/23/shu-mei-pai-kai-fa-zong-jie-01-ke-chuan-dai-shi-zhi-neng-she-bei/"/>
      <url>/2020/03/23/shu-mei-pai-kai-fa-zong-jie-01-ke-chuan-dai-shi-zhi-neng-she-bei/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="树莓派-开发总结01-可穿戴式智能设备"><a href="#树莓派-开发总结01-可穿戴式智能设备" class="headerlink" title="[树莓派-开发总结01]-可穿戴式智能设备"></a>[树莓派-开发总结01]-可穿戴式智能设备</h1><p><img src="https://pic.downk.cc/item/5e784f0c5c56091129753b1b.jpg" alt=""></p><h2 id="1-主要功能"><a href="#1-主要功能" class="headerlink" title="1. 主要功能"></a>1. 主要功能</h2><p><strong>1.**</strong>拍照** </p><p> <strong>按键控制</strong></p><p> <strong>语音控制（**</strong>USB<strong>**麦克风）</strong></p><p> <strong>手势控制</strong></p><p>2.图像识别</p><p>3.百度网盘上传</p><p><strong>4. Oled**</strong>显示**</p><p><strong>5.**</strong>语音提示（音响）**</p><h2 id="2-硬件部分"><a href="#2-硬件部分" class="headerlink" title="2.硬件部分"></a>2.硬件部分</h2><h2 id="3-软件部分"><a href="#3-软件部分" class="headerlink" title="3.软件部分"></a>3.软件部分</h2><p><img src="https://pic.downk.cc/item/5e7850295c56091129764dc1.jpg" alt="图3-1 代码结构图"></p><p><img src="https://pic.downk.cc/item/5e78506d5c56091129769b71.jpg" alt="图3-2 主程序流程图"></p><p>代码下载地址：</p><p>链接： <a href="https://www.lanzous.com/ib73elg" target="_blank" rel="noopener">https://www.lanzous.com/ib73elg</a> </p>]]></content>
      
      
      <categories>
          
          <category> 开发总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[无人机-开发总结03]-无人机数据采集</title>
      <link href="/2020/03/23/wu-ren-ji-kai-fa-zong-jie-03-wu-ren-ji-shu-ju-cai-ji/"/>
      <url>/2020/03/23/wu-ren-ji-kai-fa-zong-jie-03-wu-ren-ji-shu-ju-cai-ji/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="无人机-开发总结03-无人机数据采集"><a href="#无人机-开发总结03-无人机数据采集" class="headerlink" title="[无人机-开发总结03]-无人机数据采集"></a>[无人机-开发总结03]-无人机数据采集</h1><h2 id="1-无人机仿真模型"><a href="#1-无人机仿真模型" class="headerlink" title="1  无人机仿真模型"></a>1  无人机仿真模型</h2><h3 id="1-1-无人机结构建模"><a href="#1-1-无人机结构建模" class="headerlink" title="1.1 无人机结构建模"></a>1.1 无人机结构建模</h3><p>使用blender进行机械结构设计成品如下所示:</p><p><img src="https://s1.ax1x.com/2020/03/23/8TJtMt.jpg" alt="图1-1 无人机仿真模型"> </p><p><img src="https://s1.ax1x.com/2020/03/23/8TJdZ8.jpg" alt="图1-2 无人机仿真模型"> </p><p>将各关节导出为dae导入urdf描述文件:</p><p><img src="https://s1.ax1x.com/2020/03/23/8TJQaD.jpg" alt="图1-3 无人机3d模型文件"> </p><h2 id="2-Gazebo仿真环境"><a href="#2-Gazebo仿真环境" class="headerlink" title="2 Gazebo仿真环境"></a>2 Gazebo仿真环境</h2><p><img src="https://s1.ax1x.com/2020/03/23/8TJZx1.jpg" alt="图2-1 无人机仿真环境"> </p><h2 id="3-无人机控制程序"><a href="#3-无人机控制程序" class="headerlink" title="3 无人机控制程序"></a>3 无人机控制程序</h2><h3 id="3-1-无人机悬停控制部分"><a href="#3-1-无人机悬停控制部分" class="headerlink" title="3.1 无人机悬停控制部分"></a>3.1 无人机悬停控制部分</h3><p><img src="https://s1.ax1x.com/2020/03/23/8TJF54.jpg" alt="图3-1 无人机运动控制计算图"> </p><p>通过/NEU_m100/hovering_exmple节点不断发布向无人机发布目标位置信息，然后/NEU_m100/lee_position_controller_node节点接收目标位置信息和里程计获得的无人机位置和位姿信息，来计算出四个电机的角速度，从而控制无人机在仿真环境中的运动。</p><p>附仿真视频：</p><p>1.<a href="https://www.bilibili.com/video/av94640968" target="_blank" rel="noopener">https://www.bilibili.com/video/av94640968</a></p><p>2.<a href="https://www.bilibili.com/video/av94434635" target="_blank" rel="noopener">https://www.bilibili.com/video/av94434635</a></p><h3 id="3-2-数据集采集-水平飞-垂直飞-高低斜着飞"><a href="#3-2-数据集采集-水平飞-垂直飞-高低斜着飞" class="headerlink" title="3.2  数据集采集  (水平飞 垂直飞  高低斜着飞)"></a>3.2  数据集采集  (水平飞 垂直飞  高低斜着飞)</h3><p>运行仿真程序,将所有话题数据保存为.bag文件</p><p><img src="https://s1.ax1x.com/2020/03/23/8TJ8Gd.jpg" alt="图3-2 ROS数据集"> </p><h3 id="3-3-数据整理提取-python-shell脚本"><a href="#3-3-数据整理提取-python-shell脚本" class="headerlink" title="3.3  数据整理提取 python+shell脚本"></a>3.3  数据整理提取 python+shell脚本</h3><p>从bag中提取各个话题原始数据:</p><p><img src="https://s1.ax1x.com/2020/03/23/8TJJxI.jpg" alt="图3-3 传感器数据"></p><p>Shell脚本处理效率提升:</p><p><img src="https://s1.ax1x.com/2020/03/23/8TJwdS.jpg" alt="图3-4 shell脚本"> </p><p>数据类型:</p><p><img src="https://s1.ax1x.com/2020/03/23/8TJ0Ig.jpg" alt="图3-5 电机数据"> </p><p>Python读取txt文件并保存:</p><p><img src="https://s1.ax1x.com/2020/03/23/8TJjoD.jpg" alt="图3-6 生成训练数据集"> </p><h3 id="3-4-数据简单显示"><a href="#3-4-数据简单显示" class="headerlink" title="3.4  数据简单显示"></a>3.4  数据简单显示</h3><p>电机0转速在不同时刻的输出值显示:</p><pre class=" language-python"><code class="language-python">plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>motor_speed<span class="token punctuation">.</span>motor_time<span class="token punctuation">,</span> motor_speed<span class="token punctuation">.</span>motor_angular_velocities0<span class="token punctuation">,</span>label<span class="token operator">=</span><span class="token string">"motor0"</span><span class="token punctuation">)</span></code></pre><p><img src="https://s1.ax1x.com/2020/03/23/8TJWZT.jpg" alt="图3-7 电机数据显示"> </p>]]></content>
      
      
      <categories>
          
          <category> 开发总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无人机开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[无人机-开发总结02]-端到端无人机控制方法研究</title>
      <link href="/2020/03/22/wu-ren-ji-kai-fa-zong-jie-02-duan-dao-duan-wu-ren-ji-kong-zhi-fang-fa-yan-jiu/"/>
      <url>/2020/03/22/wu-ren-ji-kai-fa-zong-jie-02-duan-dao-duan-wu-ren-ji-kong-zhi-fang-fa-yan-jiu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-飞控模型神经网络训练"><a href="#1-飞控模型神经网络训练" class="headerlink" title="1.  飞控模型神经网络训练"></a>1.  飞控模型神经网络训练</h2><p>1）提出了一个模拟信息训练框架。</p><p>2）使用端到端策略网络，使得四旋翼能够穿越不同倾角的狭窄间隙，表明基于学习的方法也可以像传统控制方法那样解决高度动态的控制问题。</p><p><img src="https://i.loli.net/2020/03/22/8jSPYs3qfOgIzGl.jpg" alt=""></p><p>3）提出了一种基于多层感知器的最优轨迹发生器的鲁棒仿真方法。</p><p>4）说明强化学习如何提高模仿学习的性能，以及在基于模型的方法上获得更高性能的潜力。</p><p>使用端到端的神经网络来跨越窄间隙：首先用两个神经网络分别来模拟传统的运动规划和控制器，自主学习传统控制器的控制策略。输入数据为【17】个参数：</p><p><img src="https://i.loli.net/2020/03/22/cHsDWvtxX62LUoN.png" alt=""></p><p>后期使用强化学习对神经网络进行微调，以改善其性能。系统的整体框架如图所示。</p><p><img src="https://i.loli.net/2020/03/22/ahKBwZPqbLnAm3e.jpg" alt=""></p><p>图2：工作框架可以分为两个阶段，模仿和强化学习。在第一阶段，我们是通过模仿传统控制器的方法进行端到端的策略网络的学习。在第二阶段，我们使用强化学习对我们的策略网络进行微调，以改进网络性能。</p><h2 id="1-1运动路径规划器的网络"><a href="#1-1运动路径规划器的网络" class="headerlink" title="1.1运动路径规划器的网络"></a>1.1运动路径规划器的网络</h2><p>•   MLP框架如图所示。网络输入为17×1矢量，网络输出为9×1矢量。对于规划网络，它具有10个全连接层，每个层具有100个潜在单元。</p><p>•   1）数据采集：以一组随机的开始和结束状态作为训练样本，生成2万条轨迹。每条轨迹离散到1000个点，均匀分布在0和T之间。每个单轴上的起点至终点相对位置为-30∼30m，速度（vs，ve）和加速度（as，ae）分别为-10∼10m/s和-10∼10m/s2。平均速度v的变化范围为1∼7m/s。</p><p>•   考虑到训练的稳定性，手动去除输出过大的轨迹。</p><p><img src="https://i.loli.net/2020/03/22/wisnkIL8g53OHq4.jpg" alt=""></p><p><img src="https://i.loli.net/2020/03/22/ahKBwZPqbLnAm3e.jpg" alt=""></p><h2 id="1-2-四旋翼控制器网络"><a href="#1-2-四旋翼控制器网络" class="headerlink" title="1.2 四旋翼控制器网络"></a>1.2 四旋翼控制器网络</h2><p>网络的结构如图4所示。网络输入为12×1矢量，网络输出为3×1矢量。</p><p>在我们的工作中，控制器网络具有相同数量的规划网络的潜在层（如图4（a）所示）。但是，由于输入和输出维度较低，我们将潜在单元的数量从100个减少到40个。</p><p><img src="https://i.loli.net/2020/03/22/NORZq1nshBViYAx.jpg" alt=""></p><h2 id="1-3-端到端的规划和控制"><a href="#1-3-端到端的规划和控制" class="headerlink" title="1.3 端到端的规划和控制"></a>1.3 端到端的规划和控制</h2><p>在分别模拟传统的运动规划和控制器之后，我们可以将这两个网络（如图5所示）合并，称为“策略网络”。在给定间隙位姿和四转子当前状态的情况下，策略网络直接输出控制命令，与传统的控制方法一样。</p><p>策略网络的输入为29×1矢量，其中17×1为规划网络输入，12×1为当前状态。控制器网络的输入是规划网络的输出（∆pp，vp和ap）减去当前状态（包括∆pc、vc和ac）。</p><p>该策略网络的输出为3×1矢量，直接发送给四旋翼内姿态和推力控制器。</p><p><img src="https://i.loli.net/2020/03/22/LYHzgU9yfT1WMJV.jpg" alt=""></p><p>图5：端到端策略网络的输入和输出。哪里是C点Vel、C Acc分别为当前相对位置</p><p>∆pc、∆vc、ac</p><h2 id="1-4-强化学习"><a href="#1-4-强化学习" class="headerlink" title="1.4 强化学习"></a>1.4 强化学习</h2><p>1) 虚拟环境设置</p><p>为了提高训练网络的泛化能力，在不同的环境设置（不同的间隙姿态和无人机初始状态）下训练神经网络。</p><p>2) 奖励功能</p><p>在我们的RL训练中手动设计的奖励功能分为两个部分，负（罚）和正奖励项目。</p><p>（1）负奖励项：我们引入惩罚项来惩罚角速度、加速度和平移加速度的变化。</p><p><img src="https://i.loli.net/2020/03/22/2yYz7VCSWjE9AvJ.jpg" alt=""></p><p>式中，wj，wα和wj 是加权因子ω(t)和a(t)是角速度和线加速度，C是碰撞惩罚，∆t是当前时刻到最后采样时间之间的时间间隔。</p><p>在我们的工作中，wω、wα和wj的惩罚项分别设置为2×57.3、5×57.3和10。如果无人机与任何物体（如墙壁、地面等）发生碰撞，C将设置为109。</p><p>（2）正面奖励项目：当无人机到达缺口中心时，给予正面奖励</p><p><img src="https://i.loli.net/2020/03/22/xdyw9FTzl8pSfiP.jpg" alt=""></p><p>其中da是为正奖励的激活距离，S为无人机第一次获得正奖励时的一次性奖励。在我们的工作中，da和 wr是分别设置为0.15m和1000。S设为5×105。</p><p>3)  RL训练</p><p>在设计了奖励函数之后，我们使用信任域策略优化（TRPO）算法对端到端策略网络进行了微调。</p>]]></content>
      
      
      <categories>
          
          <category> 开发总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无人机开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[无人机-开发总结01]-用神经网络来控制无人机飞行</title>
      <link href="/2020/03/22/wu-ren-ji-kai-fa-zong-jie-01-yong-shen-jing-wang-luo-lai-kong-zhi-wu-ren-ji-fei-xing/"/>
      <url>/2020/03/22/wu-ren-ji-kai-fa-zong-jie-01-yong-shen-jing-wang-luo-lai-kong-zhi-wu-ren-ji-fei-xing/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="无人机-开发总结01-用神经网络来控制无人机飞行"><a href="#无人机-开发总结01-用神经网络来控制无人机飞行" class="headerlink" title="[无人机-开发总结01]-用神经网络来控制无人机飞行"></a>[无人机-开发总结01]-用神经网络来控制无人机飞行</h1><h2 id="用训练好的神经网络模型来控制无人机飞行"><a href="#用训练好的神经网络模型来控制无人机飞行" class="headerlink" title="用训练好的神经网络模型来控制无人机飞行"></a>用训练好的神经网络模型来控制无人机飞行</h2><h2 id="1-搭建飞控网络"><a href="#1-搭建飞控网络" class="headerlink" title="1.  搭建飞控网络"></a>1.  搭建飞控网络</h2><h3 id="1-1-确定网络的输入与输出数据"><a href="#1-1-确定网络的输入与输出数据" class="headerlink" title="1.1   确定网络的输入与输出数据"></a>1.1   确定网络的输入与输出数据</h3><p>网络输入数据：</p><p>维度：9维</p><p>位置误差pos_err.x, pos_err.y, pos_err.z</p><p>速度误差vel_err.x, vel_err.y, vel_err.z</p><p>欧拉角误差eluer_err.x, eluer_err.y, eluer_err.z</p><p>网络输出数据：</p><p>维度：4维</p><p>四个电机的角速度rotor_0_vel, rotor_1_vel, rotor_2_vel, rotor_3_vel</p><h3 id="1-2-搭建网络模型"><a href="#1-2-搭建网络模型" class="headerlink" title="1.2   搭建网络模型"></a>1.2   搭建网络模型</h3><p>​        在输入和输出数据类型确定完成后，考虑到输出数据有正有负，因此我们选择了tanh函数来作为我们的神经网络的激活函数。并选择了比较简单的六层全连接网络来作为我们的网络结构。将预测的电机速度与传统方法计算的电机速度求均方差，来检验网络的训练效果。选择了AdamOptimizer优化算法来训练网络模型。网络的结构图如图1-2所示。</p><h3 id="1-3-训练网络模型"><a href="#1-3-训练网络模型" class="headerlink" title="1.3   训练网络模型"></a>1.3   训练网络模型</h3><h4 id="1-3-1本地训练网络模型"><a href="#1-3-1本地训练网络模型" class="headerlink" title="1.3.1本地训练网络模型"></a>1.3.1本地训练网络模型</h4><p>​        我们采集了多次数据集，来训练我们的网络模型。首先，我们在电脑上来训练我们的网络模型。如下图为我们的训练损失下降曲线。损失最终维持在100左右。</p><p><img src="https://i.loli.net/2020/03/22/QcV7jN4uzxkBJWF.jpg" alt="图1-1损失函数下降曲线"></p><h4 id="1-3-2服务器训练网络模型"><a href="#1-3-2服务器训练网络模型" class="headerlink" title="1.3.2服务器训练网络模型"></a>1.3.2服务器训练网络模型</h4><p>​         同时，我们又在服务器上进行了更长时间的训练，通过不断增加训练的次数，来不断提高网络模型的质量。最终，我们在仿真环境中选用的网络模型参数也是从服务器上训练好的模型参数。训练过程如图1-3所示。</p><p><img src="https://i.loli.net/2020/03/22/CpA2iDXma9gfq57.jpg" alt="图1-2 网络结构图"></p><p>​                           <img src="https://i.loli.net/2020/03/22/d18zvfwVIngW3Lr.gif" alt="图1-3 服务器训练过程"> </p><h2 id="2-利用飞控网络模型控制无人机"><a href="#2-利用飞控网络模型控制无人机" class="headerlink" title="2.  利用飞控网络模型控制无人机"></a>2.  利用飞控网络模型控制无人机</h2><p>​         ROS与tensorflow的结合使用在古月的&lt;机器人制作&gt;一书中已经有所介绍,书中介绍部分是在ROS中通过调用opencv来识别物体,网友们也都是基于此开源项目展开研究的.</p><p>​         此类项目与我们所研究的重合点在于同样是编写python脚本读取无人机的odom话题与trajectory 话题message,将数据提取并处理后在放入我们第一步训练过的网络计算出无人机控制量:四个电机角速度,这一向量返回发布到speed_control话题上,即需要重构原回调函数,计算rotor_velocities(4×1),最后将其发布到话题上,通过gazebo订阅控制无人机飞行.</p><h3 id="2-1-编写ros-tensorflow接口"><a href="#2-1-编写ros-tensorflow接口" class="headerlink" title="2.1   编写ros_tensorflow接口"></a>2.1   编写ros_tensorflow接口</h3><p>​         根据思路复现的代码确实不可信，调崩了gazebo之后换新代码立马见效Rotors代码结构写的特别棒值得深入研究。</p><p>​         首先需要使用python脚本读取ros运行时话题数据，在读取消息内容上耗费了一定时间，反复rostopic info深入理解消息类型定义后才成功读取。</p><h3 id="2-2-调用网络模型进行预测"><a href="#2-2-调用网络模型进行预测" class="headerlink" title="2.2   调用网络模型进行预测"></a>2.2   调用网络模型进行预测</h3><p>​          读取完ros结点odom与的数据接下来就是跑模型预测控制量，通过初始化自定义rosnode：rostensorflow发布/NEU_m100/motor_vel话题，数据类型使用自定义float64类型msgs。</p><p>   rosrun脚本之后rostopic list确实发布了话题，rostopic echo /NEU_m100/moter_vel调用tensorflow模型出现了不少问题，这一过程确实耗费了不少时间,反复逐句调试后才成功跑通，至此ros与tensorflow脚本调用部分顺利接通.能够将仿真环境中采集到的传感器数值进行预处理后加载到tensorflow预训练模型输出四个电机转速控制量。</p><h3 id="2-3-调试结果"><a href="#2-3-调试结果" class="headerlink" title="2.3   调试结果"></a>2.3   调试结果</h3><p>​        在roscpp重新改写回调函数后成功发布电机转速控制,各话题数据均正常显示，飞机能够运动,到此全流程均已调试完成。</p><p><img src="https://i.loli.net/2020/03/22/wPCUSh2qVDo8ayb.gif" alt="图2-1 ROS运行节点计算图"></p><p>​                                                                   </p><p><img src="https://i.loli.net/2020/03/22/7HmAB9ogEuc4wK5.jpg" alt="图2-2 神经网络无人机模型飞行过程"></p><p>​                                                        </p>]]></content>
      
      
      <categories>
          
          <category> 开发总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无人机开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【经验分享02】- 破解ipad锁屏密码</title>
      <link href="/2020/01/26/ipad-suo-ping-mi-ma-wang-ji-hou-jie-jue-ban-fa/"/>
      <url>/2020/01/26/ipad-suo-ping-mi-ma-wang-ji-hou-jie-jue-ban-fa/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【经验分享02】-破解ipad锁屏密码"><a href="#【经验分享02】-破解ipad锁屏密码" class="headerlink" title="【经验分享02】- 破解ipad锁屏密码"></a>【经验分享02】- 破解ipad锁屏密码</h1><h2 id="苹果iPad设置锁屏密码忘记了怎么处理"><a href="#苹果iPad设置锁屏密码忘记了怎么处理" class="headerlink" title="苹果iPad设置锁屏密码忘记了怎么处理"></a><strong>苹果iPad设置锁屏密码忘记了怎么处理</strong></h2><h3 id="一，苹果iPad设置锁屏密码忘记了，可以通过恢复系统来还原。"><a href="#一，苹果iPad设置锁屏密码忘记了，可以通过恢复系统来还原。" class="headerlink" title="一，苹果iPad设置锁屏密码忘记了，可以通过恢复系统来还原。"></a>一，苹果iPad设置锁屏密码忘记了，可以通过恢复系统来还原。</h3><p><img src="https://ask-fd.zol-img.com.cn/g5/M00/00/08/ChMkJ1k-Df6IcqgMAADE-_OEQqgAAc9rADBoqIAAMUT305.png" alt=""></p><h3 id="二，具体操作方法："><a href="#二，具体操作方法：" class="headerlink" title="二，具体操作方法："></a>二，具体操作方法：</h3><p>第一步：电脑登陆苹果官网下载itunes，安装完毕后打开。<br>第二步：把 iPad用数据线与电脑连接起来。<br>第三步：先请长按ipad顶部的电源键，待出现关机界面后，滑动关机。<br>第四步：接着请按住电源键开机，这时屏幕会出现苹果标志，不要松开电源键。<br>第五步：随后再按住主屏 Home 键，直到屏幕黑屏。<br>第六步：屏幕黑屏时，请松开电源键，主屏 Home键不要松开，直到电脑端的 iTunes 出现检测到一个处于恢复模式的 iPad：<br>第七步：按住键盘上的“shift”键，点击“恢复”，选择相应的固件进行恢复系统即可。</p><h3 id="三，注意事项"><a href="#三，注意事项" class="headerlink" title="三，注意事项"></a>三，注意事项</h3><p>1.下载itunes比较耗时，可能要下载多次，才能成功</p><p>2.此方法需要记得自己的ipad账户和密码</p><p>3.此方法相当于给ipad重新安装一个系统</p>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常见问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【经验分享01】- 下载YouTube上面的视频</title>
      <link href="/2019/12/29/xia-zai-youtube-shang-mian-de-shi-pin/"/>
      <url>/2019/12/29/xia-zai-youtube-shang-mian-de-shi-pin/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【经验分享01】-下载YouTube上面的视频"><a href="#【经验分享01】-下载YouTube上面的视频" class="headerlink" title="【经验分享01】- 下载YouTube上面的视频"></a>【经验分享01】- 下载YouTube上面的视频</h1><h2 id="1-PC下载YouTube上面的视频"><a href="#1-PC下载YouTube上面的视频" class="headerlink" title="1.PC下载YouTube上面的视频"></a>1.PC下载YouTube上面的视频</h2><p><a href="https://en.savefrom.net/1-how-to-download-youtube-video/https://en.savefrom.net/1-how-to-download-youtube-video/" target="_blank" rel="noopener">https://en.savefrom.net/1-how-to-download-youtube-video/https://en.savefrom.net/1-how-to-download-youtube-video/</a></p><ul><li><img src="https://i.loli.net/2020/03/22/7beaoR26irBZKwC.png" alt="savefrom.net"></li></ul><h3 id="附-（MarkDown语法插入图片方法）"><a href="#附-（MarkDown语法插入图片方法）" class="headerlink" title="附.（MarkDown语法插入图片方法）"></a>附.（MarkDown语法插入图片方法）</h3><p>​        在该网站<a href="https://sm.ms/" target="_blank" rel="noopener">https://sm.ms/</a> 上上传本地图片，然后就可以复制它的链接到Markdown文件中，从而在网站上进行显示。</p>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用技能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【经验分享05】- 通过hexo搭建的博客上传文件和超链接</title>
      <link href="/2019/12/04/tong-guo-hexo-da-jian-de-bo-ke-shang-chuan-wen-jian-he-chao-lian-jie/"/>
      <url>/2019/12/04/tong-guo-hexo-da-jian-de-bo-ke-shang-chuan-wen-jian-he-chao-lian-jie/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【经验分享05】-通过hexo搭建的博客上传文件和超链接"><a href="#【经验分享05】-通过hexo搭建的博客上传文件和超链接" class="headerlink" title="【经验分享05】- 通过hexo搭建的博客上传文件和超链接"></a>【经验分享05】- 通过hexo搭建的博客上传文件和超链接</h1><h2 id="1-Hexo搭建的博客中上传文件"><a href="#1-Hexo搭建的博客中上传文件" class="headerlink" title="1.Hexo搭建的博客中上传文件"></a>1.Hexo搭建的博客中上传文件</h2><p>原文链接：<a href="https://www.zhihu.com/question/266964671" target="_blank" rel="noopener">https://www.zhihu.com/question/266964671</a></p><h2 id="2-通过蓝奏云存储"><a href="#2-通过蓝奏云存储" class="headerlink" title="2.通过蓝奏云存储"></a>2.通过蓝奏云存储</h2><p>将文件上传到蓝奏云上（非会员文件大小限制为100MB以内），然后获得文件的外链接。</p>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人网站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【经验分享03】- 添加评论功能</title>
      <link href="/2019/12/02/gei-yong-hexo-xie-de-bo-ke-tian-jia-ping-lun-gong-neng/"/>
      <url>/2019/12/02/gei-yong-hexo-xie-de-bo-ke-tian-jia-ping-lun-gong-neng/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【经验分享03】-添加评论功能"><a href="#【经验分享03】-添加评论功能" class="headerlink" title="【经验分享03】- 添加评论功能"></a>【经验分享03】- 添加评论功能</h1><h2 id="给用hexo写的博客添加评论功能"><a href="#给用hexo写的博客添加评论功能" class="headerlink" title="给用hexo写的博客添加评论功能"></a>给用hexo写的博客添加评论功能</h2><p>1.Hexo搭建的个人博客配置评论系统：Valine</p><p><a href="https://www.jianshu.com/p/59a5935c4248" target="_blank" rel="noopener">https://www.jianshu.com/p/59a5935c4248</a></p><p>2.Hexo 搭建：配置 Gitalk 评论系统</p><p><a href="https://blog.csdn.net/qq_36537546/article/details/90730412" target="_blank" rel="noopener">https://blog.csdn.net/qq_36537546/article/details/90730412</a></p>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人网站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【割胶机器人-开发总结01】- STM32F103串口使用</title>
      <link href="/2019/12/02/stm32f103-de-ge-ge-chuan-kou-shi-yong-fang-fa/"/>
      <url>/2019/12/02/stm32f103-de-ge-ge-chuan-kou-shi-yong-fang-fa/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【割胶机器人-开发总结01】-STM32F103串口使用"><a href="#【割胶机器人-开发总结01】-STM32F103串口使用" class="headerlink" title="【割胶机器人-开发总结01】- STM32F103串口使用"></a>【割胶机器人-开发总结01】- STM32F103串口使用</h1><h2 id="STM32F103的各个串口使用方法及注意事项"><a href="#STM32F103的各个串口使用方法及注意事项" class="headerlink" title="STM32F103的各个串口使用方法及注意事项"></a>STM32F103的各个串口使用方法及注意事项</h2><h2 id="1-详细使用方法"><a href="#1-详细使用方法" class="headerlink" title="1.详细使用方法"></a>1.详细使用方法</h2><p>STM32串口——5个串口的使用方法</p><p><a href="https://blog.csdn.net/qq_38351824/article/details/82777751" target="_blank" rel="noopener">https://blog.csdn.net/qq_38351824/article/details/82777751</a></p><h2 id="2-注意事项"><a href="#2-注意事项" class="headerlink" title="2.注意事项"></a>2.注意事项</h2><p>1.UASART1的所用的串口时钟是APB2（最快为72MHZ），而UASART2~5的所用的串口时钟是APB1（最快为36MHZ）；</p><p>2.STM32F103系列单片机共有5个串口，其中1-3是通用同步/异步串行接口USART(Universal Synchronous/Asynchronous Receiver/Transmitter)，4,、5是通用异步串行接口UART(Universal Asynchronous Receiver/Transmitter)。</p><p>3.在使用UASART时，如果不能正常使用，要查看串口收发的引脚是否和电阻相连。</p><p>4.在进行发送数据时，如果数据中存在0x00,需要想办法将它转换为其他格式的数据进行发送（如0x01,保证不和正确的数据冲突即可）。因为，在发送数据中，如果是0x00，相当于’\0’,串口默认该帧数据已发送结束。</p>]]></content>
      
      
      <categories>
          
          <category> 开发总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 割胶机器人 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【割胶机器人-开发总结02】- 设置树莓派为免密ssh登录</title>
      <link href="/2019/12/02/she-zhi-shu-mei-pai-wei-mian-mi-ssh-deng-lu/"/>
      <url>/2019/12/02/she-zhi-shu-mei-pai-wei-mian-mi-ssh-deng-lu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【割胶机器人-开发总结02】-设置树莓派为免密ssh登录"><a href="#【割胶机器人-开发总结02】-设置树莓派为免密ssh登录" class="headerlink" title="【割胶机器人-开发总结02】- 设置树莓派为免密ssh登录"></a>【割胶机器人-开发总结02】- 设置树莓派为免密ssh登录</h1><h2 id="1-SSH使用密钥免密码登录"><a href="#1-SSH使用密钥免密码登录" class="headerlink" title="1.SSH使用密钥免密码登录"></a>1.<a href="https://www.cnblogs.com/wangshuyi/p/6664799.html" target="_blank" rel="noopener">SSH使用密钥免密码登录</a></h2><p>原文链接：<a href="https://www.cnblogs.com/wangshuyi/p/6664799.html" target="_blank" rel="noopener">SSH使用密钥免密码登录</a></p><p>使用ssh远程连接服务器，有两种身份校验方式：账号密码和秘钥。使用秘钥的方式理论上更加安全，而且免去了输入密码的步骤，使用起来更方便（尤其对于sftp,scp等）。</p><h3 id="设置-SSH，打开密钥登录功能"><a href="#设置-SSH，打开密钥登录功能" class="headerlink" title="设置 SSH，打开密钥登录功能"></a>设置 SSH，打开密钥登录功能</h3><p>编辑 /etc/ssh/sshd_config 文件，进行如下设置：</p><pre><code>RSAAuthentication yesPubkeyAuthentication yes</code></pre><p>留意 root 用户能否通过 SSH 登录：</p><pre><code>PermitRootLogin yes</code></pre><p>当你完成全部设置，并以密钥方式登录成功后，再禁用密码登录：</p><pre><code>PasswordAuthentication no</code></pre><p>最后，重启 SSH 服务：</p><pre><code>[root@host .ssh]$ service sshd restart</code></pre><ol><li><p>秘钥由谁生成<br>这是比较容易搞乱的一点。这里以A、B两台服务器为例，假设A需要ssh登录B，那么应该由那台服务器生成秘钥呢。可能有人以为像门锁一样，主人家负责装锁配钥匙，把钥匙交给要开门的人使用，所以由被访问的B服务器生成秘钥。</p><p>事实恰恰相反，秘钥由访问请求方A服务器生成，并把生成的公钥交给B导入；公钥可以在多台服务器导入，一台服务器导入了A的公钥，即意味着承认A的有访问自己权限，所以A可以用一套密钥登录多台服务器。</p></li></ol><ol start="2"><li>账号<br>访问和被访问的服务，需要有相同的账号，而且密钥由该账号生成。</li></ol><ol start="3"><li>密钥生成<br>在A服务器上执行命令：<br><strong>ssh-keygen -t [rsa|dsa]</strong><br>rsa和dsa是生成密钥常用的两种加密算法，其他可选算法还有ecdsa、rsa1等。<br>命令执行过程需要用户输入的地方连续回车即可（enter passphrase的别输入，否则登录的时候还是得输入密钥密码）。<br>执行成功后，在用户home目录下的.ssh子目录里会生成私钥文件和公钥文件：id_rsa,id_rsa.pub或id_dsa,id_dsa.pub。</li></ol><ol start="4"><li><p>公钥导入<br><strong>方法一：</strong><br>把公钥文件id_rsa.pub上传到B服务器，然后执行：<br><strong>cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</strong><br>将id_rsa.pub的内容，追加到文件~/.ssh/authorized_keys中</p><p><strong>方法二：</strong>在A服务器上使用命令cat <del>/.ssh/id_rsa.pub查看公钥内容，将内容复制<strong>追加</strong>到B服务器的文件</del>/.ssh/authorized_keys中（请注意不要删除或覆盖该文件中已有的内容）。</p></li></ol><ol start="5"><li><p>修改权限<br>A服务器上的.ssh和秘钥文件的权限在ssh-keygen生成时已设好，无须特别设置。B服务器上如果是首次添加authorized_keys，需要修改权限：<br><strong>chmod 600 authorized_keys</strong><br>设置authorized_keys权限</p><p><strong>chmod 700 -R .ssh</strong><br>设置.ssh目录权限</p></li></ol><ol start="6"><li><p>登录<br>在A服务器上执行：<br><strong>ssh-add /id_rsa</strong><br>必须保证id_rsa文件的权限为600<br>ssh ip/hostname（B服务器的ip或主机名）<br>即可登录。</p></li><li><p>问题Could not open a connection to your authentication agent<br>先执行  eval <code>ssh-agent</code>  （是～键上的那个`） 再执行 ssh-add ~/.ssh/rsa成功</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 开发总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 割胶机器人 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【经验分享04】- 给网站添加音乐、图片和视频</title>
      <link href="/2019/11/28/gei-wang-zhan-tian-jia-yin-le-he-tu-pian/"/>
      <url>/2019/11/28/gei-wang-zhan-tian-jia-yin-le-he-tu-pian/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【经验分享04】-给网站添加音乐、图片和视频"><a href="#【经验分享04】-给网站添加音乐、图片和视频" class="headerlink" title="【经验分享04】- 给网站添加音乐、图片和视频"></a>【经验分享04】- 给网站添加音乐、图片和视频</h1><h2 id="1-音乐外链生成网站"><a href="#1-音乐外链生成网站" class="headerlink" title="1.音乐外链生成网站"></a>1.音乐外链生成网站</h2><p> <a href="http://www.333ttt.com/up/" target="_blank" rel="noopener">http://www.333ttt.com/up/</a> </p><p>在该网站搜索需要的音乐或者歌手，最网页最下方就可以获得该歌曲的外链接。最后在Hexo/_data文件夹下的music.json文件中加入该外链接即可。</p><h2 id="2-图片外链生成网站"><a href="#2-图片外链生成网站" class="headerlink" title="2.图片外链生成网站"></a>2.图片外链生成网站</h2><p> <a href="https://sm.ms/" target="_blank" rel="noopener">https://sm.ms/</a> </p><p> <a href="https://imgchr.com/" target="_blank" rel="noopener">https://imgchr.com/</a> (推荐使用)</p><p>直接在该网站上上传需要的照片，就可以获得该图片的外链接了。</p><h2 id="3-插入视频"><a href="#3-插入视频" class="headerlink" title="3.插入视频"></a>3.插入视频</h2><iframe height=560 width=800 src="//player.bilibili.com/player.html?aid=94640968&cid=161566089&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人网站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建个人网站</title>
      <link href="/2019/11/28/da-jian-ge-ren-wang-zhan/"/>
      <url>/2019/11/28/da-jian-ge-ren-wang-zhan/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1.搭建GitHub免费个人网站（详细教程</p><p><a href="https://blog.csdn.net/qq_43270074/article/details/95392429" target="_blank" rel="noopener">https://blog.csdn.net/qq_43270074/article/details/95392429</a></p><p>2.手把手教你用Hexo+Github 搭建属于自己的博客</p><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/53576018" target="_blank" rel="noopener">https://blog.csdn.net/gdutxiaoxu/article/details/53576018</a></p><p>3.利用Github Page 搭建个人博客网站</p><p><a href="https://blog.csdn.net/tzs_1041218129/article/details/53214497" target="_blank" rel="noopener">https://blog.csdn.net/tzs_1041218129/article/details/53214497</a></p><p>4.手把手教你如何在GitHub上搭建属于自己的免费网站</p><p><a href="https://blog.csdn.net/weixin_40845165/article/details/78976206" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40845165/article/details/78976206</a></p><p>5.如何利用GitHub设计一个炫酷的个人网站（含代码）</p><p><a href="https://blog.csdn.net/weixin_34210740/article/details/93334660" target="_blank" rel="noopener">https://blog.csdn.net/weixin_34210740/article/details/93334660</a></p><p>6.这是一个采用<code>Material Design</code>和响应式设计的 Hexo 博客主题。</p><p><a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/" target="_blank" rel="noopener">https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 个人网站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/11/27/hello-world/"/>
      <url>/2019/11/27/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
